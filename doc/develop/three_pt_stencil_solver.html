<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: The three-pt-stencil-solver program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from remotes/origin/develop branch based on develop. Ginkgo version 1.0.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The three-pt-stencil-solver program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The 3-point stencil example.</p>
<p>This example depends on simple-solver, poisson-solver.</p>
<p> 
<table class="example" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Abouttheexample"> About the example </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
      <ul>
        <li><a href="#Commentsaboutprogramminganddebugging"> Comments about programming and debugging </a>
    </ul>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 <a class="anchor" id="Intro"></a> <a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>This example solves a 1D Poisson equation:</p>
<p><img class="formulaInl" alt="$ u : [0, 1] \rightarrow R\\ u'' = f\\ u(0) = u0\\ u(1) = u1 $" src="form_15.png"/></p>
<p>using a finite difference method on an equidistant grid with <code>K</code> discretization points (<code>K</code> can be controlled with a command line parameter). The discretization is done via the second order Taylor polynomial:</p>
<p><img class="formulaInl" alt="$ u(x + h) = u(x) - u'(x)h + 1/2 u''(x)h^2 + O(h^3)\\ u(x - h) = u(x) + u'(x)h + 1/2 u''(x)h^2 + O(h^3) / +\\ ---------------------- \\ -u(x - h) + 2u(x) + -u(x + h) = -f(x)h^2 + O(h^3) $" src="form_16.png"/></p>
<p>For an equidistant grid with K "inner" discretization points <img class="formulaInl" alt="$x1, ..., xk, $" src="form_17.png"/>and step size <img class="formulaInl" alt="$ h = 1 / (K + 1)$" src="form_18.png"/>, the formula produces a system of linear equations</p>
<p><img class="formulaInl" alt="$ 2u_1 - u_2 = -f_1 h^2 + u0\\ -u_(k-1) + 2u_k - u_(k+1) = -f_k h^2, k = 2, ..., K - 1\\ -u_(K-1) + 2u_K = -f_K h^2 + u1\\ $" src="form_19.png"/></p>
<p>which is then solved using Ginkgo's implementation of the CG method preconditioned with block-Jacobi. It is also possible to specify on which executor Ginkgo will solve the system via the command line. The function <img class="formulaInl" alt="$`f` $" src="form_20.png"/>is set to <img class="formulaInl" alt="$`f(x) = 6x`$" src="form_21.png"/> (making the solution <img class="formulaInl" alt="$`u(x) = x^3`$" src="form_22.png"/>), but that can be changed in the <code>main</code> function.</p>
<p>The intention of the example is to show how Ginkgo can be integrated into existing software - the <code>generate_stencil_matrix</code>, <code>generate_rhs</code>, <code>print_solution</code>, <code>compute_error</code> and <code>main</code> function do not reference Ginkgo at all (i.e. they could have been there before the application developer decided to use Ginkgo, and the only part where Ginkgo is introduced is inside the <code>solve_system</code> function.</p>
<p><a class="anchor" id="Abouttheexample"></a></p><h3>About the example </h3>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<div class="fragment"><div class="line">/ *****************************&lt;DECSRIPTION&gt;***********************************</div><div class="line">This example solves a 1D Poisson equation:</div><div class="line"></div><div class="line">    u : [0, 1] -&gt; R</div><div class="line">    u<span class="stringliteral">&#39;&#39;</span> = f</div><div class="line">    u(0) = u0</div><div class="line">    u(1) = u1</div><div class="line"></div><div class="line"><span class="keyword">using</span> a finite difference method on an equidistant grid with `K` discretization</div><div class="line">points (`K` can be controlled with a command line parameter). The discretization</div><div class="line">is done via the second order Taylor polynomial:</div><div class="line"></div><div class="line">u(x + h) = u(x) - u<span class="stringliteral">&#39;(x)h + 1/2 u&#39;</span><span class="stringliteral">&#39;(x)h^2 + O(h^3)</span></div><div class="line"><span class="stringliteral">u(x - h) = u(x) + u&#39;</span>(x)h + 1/2 u<span class="stringliteral">&#39;&#39;</span>(x)h^2 + O(h^3)  / +</div><div class="line">---------------------------------------------</div><div class="line">-u(x - h) + 2u(x) + -u(x + h) = -f(x)h^2 + O(h^3)</div><div class="line"></div><div class="line">For an equidistant grid with K <span class="stringliteral">&quot;inner&quot;</span> discretization points x1, ..., xk, and</div><div class="line">step size h = 1 / (K + 1), the formula produces a system of linear equations</div><div class="line"></div><div class="line">           2u_1 - u_2     = -f_1 h^2 + u0</div><div class="line">-u_(k-1) + 2u_k - u_(k+1) = -f_k h^2,       k = 2, ..., K - 1</div><div class="line">-u_(K-1) + 2u_K           = -f_K h^2 + u1</div><div class="line"></div><div class="line"></div><div class="line">which is then solved <span class="keyword">using</span> Ginkgo<span class="stringliteral">&#39;s implementation of the CG method</span></div><div class="line"><span class="stringliteral">preconditioned with block-Jacobi. It is also possible to specify on which</span></div><div class="line"><span class="stringliteral">executor Ginkgo will solve the system via the command line.</span></div><div class="line"><span class="stringliteral">The function `f` is set to `f(x) = 6x` (making the solution `u(x) = x^3`), but</span></div><div class="line"><span class="stringliteral">that can be changed in the `main` function.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">The intention of the example is to show how Ginkgo can be integrated into</span></div><div class="line"><span class="stringliteral">existing software - the `generate_stencil_matrix`, `generate_rhs`,</span></div><div class="line"><span class="stringliteral">`print_solution`, `compute_error` and `main` function do not reference Ginkgo at</span></div><div class="line"><span class="stringliteral">all (i.e. they could have been there before the application developer decided to</span></div><div class="line"><span class="stringliteral">use Ginkgo, and the only part where Ginkgo is introduced is inside the</span></div><div class="line"><span class="stringliteral">`solve_system` function.</span></div><div class="line"><span class="stringliteral">*****************************&lt;DECSRIPTION&gt;********************************** /</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">#include &lt;ginkgo/ginkgo.hpp&gt;</span></div><div class="line"><span class="stringliteral">#include &lt;iostream&gt;</span></div><div class="line"><span class="stringliteral">#include &lt;map&gt;</span></div><div class="line"><span class="stringliteral">#include &lt;string&gt;</span></div><div class="line"><span class="stringliteral">#include &lt;vector&gt;</span></div></div><!-- fragment --><p>Creates a stencil matrix in CSR format for the given number of discretization points.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> generate_stencil_matrix(<span class="keywordtype">int</span> discretization_points, <span class="keywordtype">int</span> *row_ptrs,</div><div class="line">                             <span class="keywordtype">int</span> *col_idxs, <span class="keywordtype">double</span> *values)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> pos = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coefs[] = {-1, 2, -1};</div><div class="line">    row_ptrs[0] = pos;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ofs : {-1, 0, 1}) {</div><div class="line">            <span class="keywordflow">if</span> (0 &lt;= i + ofs &amp;&amp; i + ofs &lt; discretization_points) {</div><div class="line">                values[pos] = coefs[ofs + 1];</div><div class="line">                col_idxs[pos] = i + ofs;</div><div class="line">                ++pos;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        row_ptrs[i + 1] = pos;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Generates the RHS vector given <code>f</code> and the boundary conditions.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Closure&gt;</div><div class="line"><span class="keywordtype">void</span> generate_rhs(<span class="keywordtype">int</span> discretization_points, Closure f, <span class="keywordtype">double</span> u0, <span class="keywordtype">double</span> u1,</div><div class="line">                  <span class="keywordtype">double</span> *rhs)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h = 1.0 / (discretization_points + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> xi = (i + 1) * h;</div><div class="line">        rhs[i] = -f(xi) * h * h;</div><div class="line">    }</div><div class="line">    rhs[0] += u0;</div><div class="line">    rhs[discretization_points - 1] += u1;</div><div class="line">}</div></div><!-- fragment --><p>Prints the solution <code>u</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> print_solution(<span class="keywordtype">int</span> discretization_points, <span class="keywordtype">double</span> u0, <span class="keywordtype">double</span> u1,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> *u)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; u0 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        std::cout &lt;&lt; u[i] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; u1 &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>Computes the 1-norm of the error given the computed <code>u</code> and the correct solution function <code>correct_u</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Closure&gt;</div><div class="line"><span class="keywordtype">double</span> calculate_error(<span class="keywordtype">int</span> discretization_points, <span class="keyword">const</span> <span class="keywordtype">double</span> *u,</div><div class="line">                       Closure correct_u)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h = 1.0 / (discretization_points + 1);</div><div class="line">    <span class="keyword">auto</span> error = 0.0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keyword">using</span> std::abs;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> xi = (i + 1) * h;</div><div class="line">        error += <a class="code" href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">abs</a>(u[i] - correct_u(xi)) / <a class="code" href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">abs</a>(correct_u(xi));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> error;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve_system(<span class="keyword">const</span> std::string &amp;executor_string,</div><div class="line">                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> discretization_points, <span class="keywordtype">int</span> *row_ptrs,</div><div class="line">                  <span class="keywordtype">int</span> *col_idxs, <span class="keywordtype">double</span> *values, <span class="keywordtype">double</span> *rhs, <span class="keywordtype">double</span> *u,</div><div class="line">                  <span class="keywordtype">double</span> accuracy)</div><div class="line">{</div></div><!-- fragment --><p>Some shortcuts</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> vec = gko::matrix::Dense&lt;double&gt;;</div><div class="line"><span class="keyword">using</span> mtx = gko::matrix::Csr&lt;double, int&gt;;</div><div class="line"><span class="keyword">using</span> cg = gko::solver::Cg&lt;double&gt;;</div><div class="line"><span class="keyword">using</span> bj = <a class="code" href="classgko_1_1preconditioner_1_1Jacobi.html">gko::preconditioner::Jacobi&lt;double, int&gt;</a>;</div><div class="line"><span class="keyword">using</span> val_array = <a class="code" href="classgko_1_1Array.html">gko::Array&lt;double&gt;</a>;</div><div class="line"><span class="keyword">using</span> idx_array = <a class="code" href="classgko_1_1Array.html">gko::Array&lt;int&gt;</a>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;dp = discretization_points;</div></div><!-- fragment --><p>Figure out where to run the code</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> omp = <a class="code" href="classgko_1_1OmpExecutor.html#a33ca05fdd0fc928ee262fc9425304874">gko::OmpExecutor::create</a>();</div><div class="line">std::map&lt;std::string, std::shared_ptr&lt;gko::Executor&gt;&gt; exec_map{</div><div class="line">    {<span class="stringliteral">&quot;omp&quot;</span>, omp},</div><div class="line">    {<span class="stringliteral">&quot;cuda&quot;</span>, <a class="code" href="classgko_1_1CudaExecutor.html#a2718a92034350650ef406ffdb60db090">gko::CudaExecutor::create</a>(0, omp)},</div><div class="line">    {<span class="stringliteral">&quot;reference&quot;</span>, gko::ReferenceExecutor::create()}};</div></div><!-- fragment --><p>executor where Ginkgo will perform the computation</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> exec = exec_map.at(executor_string);  <span class="comment">// throws if not valid</span></div></div><!-- fragment --><p>executor where the application initialized the data</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> app_exec = exec_map[<span class="stringliteral">&quot;omp&quot;</span>];</div></div><!-- fragment --><p>Tell Ginkgo to use the data in our application</p>
<p>Matrix: we have to set the executor of the matrix to the one where we want SpMVs to run (in this case <code>exec</code>). When creating array views, we have to specify the executor where the data is (in this case <code>app_exec</code>).</p>
<p>If the two do not match, Ginkgo will automatically create a copy of the data on <code>exec</code> (however, it will not copy the data back once it is done</p><ul>
<li>here this is not important since we are not modifying the matrix).</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> matrix = mtx::create(exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp),</div><div class="line">                          val_array::view(app_exec, 3 * dp - 2, values),</div><div class="line">                          idx_array::view(app_exec, 3 * dp - 2, col_idxs),</div><div class="line">                          idx_array::view(app_exec, dp + 1, row_ptrs));</div></div><!-- fragment --><p>RHS: similar to matrix</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> b = vec::create(exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp, 1),</div><div class="line">                     val_array::view(app_exec, dp, rhs), 1);</div></div><!-- fragment --><p>Solution: we have to be careful here - if the executors are different, once we compute the solution the array will not be automatically copied back to the original memory locations. Fortunately, whenever <code>apply</code> is called on a linear operator (e.g. matrix, solver) the arguments automatically get copied to the executor where the operator is, and copied back once the operation is completed. Thus, in this case, we can just define the solution on <code>app_exec</code>, and it will be automatically transferred to/from <code>exec</code> if needed.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = vec::create(app_exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp, 1),</div><div class="line">                     val_array::view(app_exec, dp, u), 1);</div></div><!-- fragment --><p>Generate solver</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> solver_gen =</div><div class="line">    cg::build()</div><div class="line">        .with_criteria(</div><div class="line">            gko::stop::Iteration::build().with_max_iters(dp).on(exec),</div><div class="line">            <a class="code" href="classgko_1_1stop_1_1ResidualNormReduction.html">gko::stop::ResidualNormReduction&lt;&gt;::build</a>()</div><div class="line">                .with_reduction_factor(accuracy)</div><div class="line">                .on(exec))</div><div class="line">        .with_preconditioner(bj::build().on(exec))</div><div class="line">        .on(exec);</div><div class="line"><span class="keyword">auto</span> solver = solver_gen-&gt;generate(<a class="code" href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">gko::give</a>(matrix));</div></div><!-- fragment --><p>Solve system</p>
<div class="fragment"><div class="line">    solver-&gt;apply(<a class="code" href="namespacegko.html#aa8cb4876b72e5e1036ea9575443c439b">gko::lend</a>(b), <a class="code" href="namespacegko.html#aa8cb4876b72e5e1036ea9575443c439b">gko::lend</a>(x));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; DISCRETIZATION_POINTS [executor]&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        std::exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> discretization_points = argc &gt;= 2 ? std::atoi(argv[1]) : 100;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> executor_string = argc &gt;= 3 ? argv[2] : <span class="stringliteral">&quot;reference&quot;</span>;</div></div><!-- fragment --><p>problem:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> correct_u = [](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * x * x; };</div><div class="line"><span class="keyword">auto</span> f = [](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> 6 * x; };</div><div class="line"><span class="keyword">auto</span> u0 = correct_u(0);</div><div class="line"><span class="keyword">auto</span> u1 = correct_u(1);</div></div><!-- fragment --><p>matrix</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; row_ptrs(discretization_points + 1);</div><div class="line">std::vector&lt;int&gt; col_idxs(3 * discretization_points - 2);</div><div class="line">std::vector&lt;double&gt; values(3 * discretization_points - 2);</div></div><!-- fragment --><p>right hand side</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; rhs(discretization_points);</div></div><!-- fragment --><p>solution</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; u(discretization_points, 0.0);</div><div class="line"></div><div class="line">generate_stencil_matrix(discretization_points, row_ptrs.data(),</div><div class="line">                        col_idxs.data(), values.data());</div></div><!-- fragment --><p>looking for solution u = x^3: f = 6x, u(0) = 0, u(1) = 1</p>
<div class="fragment"><div class="line">    generate_rhs(discretization_points, f, u0, u1, rhs.data());</div><div class="line"></div><div class="line">    solve_system(executor_string, discretization_points, row_ptrs.data(),</div><div class="line">                 col_idxs.data(), values.data(), rhs.data(), u.data(), 1e-12);</div><div class="line"></div><div class="line">    print_solution(discretization_points, 0, 1, u.data());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The average relative error is &quot;</span></div><div class="line">              &lt;&lt; calculate_error(discretization_points, u.data(), correct_u) /</div><div class="line">                     discretization_points</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> <a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>This is the expected output:</p>
<div class="fragment"><div class="line">0</div><div class="line">0.00010798</div><div class="line">0.000863838</div><div class="line">0.00291545</div><div class="line">0.0069107</div><div class="line">0.0134975</div><div class="line">0.0233236</div><div class="line">0.037037</div><div class="line">0.0552856</div><div class="line">0.0787172</div><div class="line">0.10798</div><div class="line">0.143721</div><div class="line">0.186589</div><div class="line">0.237231</div><div class="line">0.296296</div><div class="line">0.364431</div><div class="line">0.442285</div><div class="line">0.530504</div><div class="line">0.629738</div><div class="line">0.740633</div><div class="line">0.863838</div><div class="line">1</div><div class="line">The average relative error is 1.87318e-15</div></div><!-- fragment --><p><a class="anchor" id="Commentsaboutprogramminganddebugging"></a></p><h4>Comments about programming and debugging </h4>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"><span class="comment">/*******************************&lt;GINKGO LICENSE&gt;******************************</span></div><div class="line"><span class="comment">Copyright (c) 2017-2019, the Ginkgo authors</span></div><div class="line"><span class="comment">All rights reserved.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">Redistribution and use in source and binary forms, with or without</span></div><div class="line"><span class="comment">modification, are permitted provided that the following conditions</span></div><div class="line"><span class="comment">are met:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">1. Redistributions of source code must retain the above copyright</span></div><div class="line"><span class="comment">notice, this list of conditions and the following disclaimer.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">2. Redistributions in binary form must reproduce the above copyright</span></div><div class="line"><span class="comment">notice, this list of conditions and the following disclaimer in the</span></div><div class="line"><span class="comment">documentation and/or other materials provided with the distribution.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">3. Neither the name of the copyright holder nor the names of its</span></div><div class="line"><span class="comment">contributors may be used to endorse or promote products derived from</span></div><div class="line"><span class="comment">this software without specific prior written permission.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span></div><div class="line"><span class="comment">IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED</span></div><div class="line"><span class="comment">TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A</span></div><div class="line"><span class="comment">PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span></div><div class="line"><span class="comment">HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span></div><div class="line"><span class="comment">SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span></div><div class="line"><span class="comment">LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span></div><div class="line"><span class="comment">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span></div><div class="line"><span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span></div><div class="line"><span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span></div><div class="line"><span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span></div><div class="line"><span class="comment">******************************&lt;GINKGO LICENSE&gt;*******************************/</span></div><div class="line"></div><div class="line"><span class="comment">/*****************************&lt;DECSRIPTION&gt;***********************************</span></div><div class="line"><span class="comment">This example solves a 1D Poisson equation:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    u : [0, 1] -&gt; R</span></div><div class="line"><span class="comment">    u&#39;&#39; = f</span></div><div class="line"><span class="comment">    u(0) = u0</span></div><div class="line"><span class="comment">    u(1) = u1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">using a finite difference method on an equidistant grid with `K` discretization</span></div><div class="line"><span class="comment">points (`K` can be controlled with a command line parameter). The discretization</span></div><div class="line"><span class="comment">is done via the second order Taylor polynomial:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">u(x + h) = u(x) - u&#39;(x)h + 1/2 u&#39;&#39;(x)h^2 + O(h^3)</span></div><div class="line"><span class="comment">u(x - h) = u(x) + u&#39;(x)h + 1/2 u&#39;&#39;(x)h^2 + O(h^3)  / +</span></div><div class="line"><span class="comment">---------------------------------------------</span></div><div class="line"><span class="comment">-u(x - h) + 2u(x) + -u(x + h) = -f(x)h^2 + O(h^3)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">For an equidistant grid with K &quot;inner&quot; discretization points x1, ..., xk, and</span></div><div class="line"><span class="comment">step size h = 1 / (K + 1), the formula produces a system of linear equations</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">           2u_1 - u_2     = -f_1 h^2 + u0</span></div><div class="line"><span class="comment">-u_(k-1) + 2u_k - u_(k+1) = -f_k h^2,       k = 2, ..., K - 1</span></div><div class="line"><span class="comment">-u_(K-1) + 2u_K           = -f_K h^2 + u1</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">which is then solved using Ginkgo&#39;s implementation of the CG method</span></div><div class="line"><span class="comment">preconditioned with block-Jacobi. It is also possible to specify on which</span></div><div class="line"><span class="comment">executor Ginkgo will solve the system via the command line.</span></div><div class="line"><span class="comment">The function `f` is set to `f(x) = 6x` (making the solution `u(x) = x^3`), but</span></div><div class="line"><span class="comment">that can be changed in the `main` function.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">The intention of the example is to show how Ginkgo can be integrated into</span></div><div class="line"><span class="comment">existing software - the `generate_stencil_matrix`, `generate_rhs`,</span></div><div class="line"><span class="comment">`print_solution`, `compute_error` and `main` function do not reference Ginkgo at</span></div><div class="line"><span class="comment">all (i.e. they could have been there before the application developer decided to</span></div><div class="line"><span class="comment">use Ginkgo, and the only part where Ginkgo is introduced is inside the</span></div><div class="line"><span class="comment">`solve_system` function.</span></div><div class="line"><span class="comment">*****************************&lt;DECSRIPTION&gt;**********************************/</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;ginkgo/ginkgo.hpp&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> generate_stencil_matrix(<span class="keywordtype">int</span> discretization_points, <span class="keywordtype">int</span> *row_ptrs,</div><div class="line">                             <span class="keywordtype">int</span> *col_idxs, <span class="keywordtype">double</span> *values)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> pos = 0;</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> coefs[] = {-1, 2, -1};</div><div class="line">    row_ptrs[0] = pos;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> ofs : {-1, 0, 1}) {</div><div class="line">            <span class="keywordflow">if</span> (0 &lt;= i + ofs &amp;&amp; i + ofs &lt; discretization_points) {</div><div class="line">                values[pos] = coefs[ofs + 1];</div><div class="line">                col_idxs[pos] = i + ofs;</div><div class="line">                ++pos;</div><div class="line">            }</div><div class="line">        }</div><div class="line">        row_ptrs[i + 1] = pos;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Closure&gt;</div><div class="line"><span class="keywordtype">void</span> generate_rhs(<span class="keywordtype">int</span> discretization_points, Closure f, <span class="keywordtype">double</span> u0, <span class="keywordtype">double</span> u1,</div><div class="line">                  <span class="keywordtype">double</span> *rhs)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h = 1.0 / (discretization_points + 1);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> xi = (i + 1) * h;</div><div class="line">        rhs[i] = -f(xi) * h * h;</div><div class="line">    }</div><div class="line">    rhs[0] += u0;</div><div class="line">    rhs[discretization_points - 1] += u1;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> print_solution(<span class="keywordtype">int</span> discretization_points, <span class="keywordtype">double</span> u0, <span class="keywordtype">double</span> u1,</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">double</span> *u)</div><div class="line">{</div><div class="line">    std::cout &lt;&lt; u0 &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        std::cout &lt;&lt; u[i] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div><div class="line">    }</div><div class="line">    std::cout &lt;&lt; u1 &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Closure&gt;</div><div class="line"><span class="keywordtype">double</span> calculate_error(<span class="keywordtype">int</span> discretization_points, <span class="keyword">const</span> <span class="keywordtype">double</span> *u,</div><div class="line">                       Closure correct_u)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> h = 1.0 / (discretization_points + 1);</div><div class="line">    <span class="keyword">auto</span> error = 0.0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; discretization_points; ++i) {</div><div class="line">        <span class="keyword">using</span> std::abs;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> xi = (i + 1) * h;</div><div class="line">        error += <a class="code" href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">abs</a>(u[i] - correct_u(xi)) / <a class="code" href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">abs</a>(correct_u(xi));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> error;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> solve_system(<span class="keyword">const</span> std::string &amp;executor_string,</div><div class="line">                  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> discretization_points, <span class="keywordtype">int</span> *row_ptrs,</div><div class="line">                  <span class="keywordtype">int</span> *col_idxs, <span class="keywordtype">double</span> *values, <span class="keywordtype">double</span> *rhs, <span class="keywordtype">double</span> *u,</div><div class="line">                  <span class="keywordtype">double</span> accuracy)</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> vec = gko::matrix::Dense&lt;double&gt;;</div><div class="line">    <span class="keyword">using</span> mtx = gko::matrix::Csr&lt;double, int&gt;;</div><div class="line">    <span class="keyword">using</span> cg = gko::solver::Cg&lt;double&gt;;</div><div class="line">    <span class="keyword">using</span> bj = <a class="code" href="classgko_1_1preconditioner_1_1Jacobi.html">gko::preconditioner::Jacobi&lt;double, int&gt;</a>;</div><div class="line">    <span class="keyword">using</span> val_array = <a class="code" href="classgko_1_1Array.html">gko::Array&lt;double&gt;</a>;</div><div class="line">    <span class="keyword">using</span> idx_array = <a class="code" href="classgko_1_1Array.html">gko::Array&lt;int&gt;</a>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;dp = discretization_points;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> omp = <a class="code" href="classgko_1_1OmpExecutor.html#a33ca05fdd0fc928ee262fc9425304874">gko::OmpExecutor::create</a>();</div><div class="line">    std::map&lt;std::string, std::shared_ptr&lt;gko::Executor&gt;&gt; exec_map{</div><div class="line">        {<span class="stringliteral">&quot;omp&quot;</span>, omp},</div><div class="line">        {<span class="stringliteral">&quot;cuda&quot;</span>, <a class="code" href="classgko_1_1CudaExecutor.html#a2718a92034350650ef406ffdb60db090">gko::CudaExecutor::create</a>(0, omp)},</div><div class="line">        {<span class="stringliteral">&quot;reference&quot;</span>, gko::ReferenceExecutor::create()}};</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> exec = exec_map.at(executor_string);  <span class="comment">// throws if not valid</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> app_exec = exec_map[<span class="stringliteral">&quot;omp&quot;</span>];</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">auto</span> matrix = mtx::create(exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp),</div><div class="line">                              val_array::view(app_exec, 3 * dp - 2, values),</div><div class="line">                              idx_array::view(app_exec, 3 * dp - 2, col_idxs),</div><div class="line">                              idx_array::view(app_exec, dp + 1, row_ptrs));</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> b = vec::create(exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp, 1),</div><div class="line">                         val_array::view(app_exec, dp, rhs), 1);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> x = vec::create(app_exec, <a class="code" href="structgko_1_1dim.html">gko::dim&lt;2&gt;</a>(dp, 1),</div><div class="line">                         val_array::view(app_exec, dp, u), 1);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> solver_gen =</div><div class="line">        cg::build()</div><div class="line">            .with_criteria(</div><div class="line">                gko::stop::Iteration::build().with_max_iters(dp).on(exec),</div><div class="line">                <a class="code" href="classgko_1_1stop_1_1ResidualNormReduction.html">gko::stop::ResidualNormReduction&lt;&gt;::build</a>()</div><div class="line">                    .with_reduction_factor(accuracy)</div><div class="line">                    .on(exec))</div><div class="line">            .with_preconditioner(bj::build().on(exec))</div><div class="line">            .on(exec);</div><div class="line">    <span class="keyword">auto</span> solver = solver_gen-&gt;generate(<a class="code" href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">gko::give</a>(matrix));</div><div class="line"></div><div class="line">    solver-&gt;apply(<a class="code" href="namespacegko.html#aa8cb4876b72e5e1036ea9575443c439b">gko::lend</a>(b), <a class="code" href="namespacegko.html#aa8cb4876b72e5e1036ea9575443c439b">gko::lend</a>(x));</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (argc &lt; 2) {</div><div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; DISCRETIZATION_POINTS [executor]&quot;</span></div><div class="line">                  &lt;&lt; std::endl;</div><div class="line">        std::exit(-1);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> discretization_points = argc &gt;= 2 ? std::atoi(argv[1]) : 100;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> executor_string = argc &gt;= 3 ? argv[2] : <span class="stringliteral">&quot;reference&quot;</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> correct_u = [](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> x * x * x; };</div><div class="line">    <span class="keyword">auto</span> f = [](<span class="keywordtype">double</span> x) { <span class="keywordflow">return</span> 6 * x; };</div><div class="line">    <span class="keyword">auto</span> u0 = correct_u(0);</div><div class="line">    <span class="keyword">auto</span> u1 = correct_u(1);</div><div class="line"></div><div class="line">    std::vector&lt;int&gt; row_ptrs(discretization_points + 1);</div><div class="line">    std::vector&lt;int&gt; col_idxs(3 * discretization_points - 2);</div><div class="line">    std::vector&lt;double&gt; values(3 * discretization_points - 2);</div><div class="line">    std::vector&lt;double&gt; rhs(discretization_points);</div><div class="line">    std::vector&lt;double&gt; u(discretization_points, 0.0);</div><div class="line"></div><div class="line">    generate_stencil_matrix(discretization_points, row_ptrs.data(),</div><div class="line">                            col_idxs.data(), values.data());</div><div class="line">    generate_rhs(discretization_points, f, u0, u1, rhs.data());</div><div class="line"></div><div class="line">    solve_system(executor_string, discretization_points, row_ptrs.data(),</div><div class="line">                 col_idxs.data(), values.data(), rhs.data(), u.data(), 1e-12);</div><div class="line"></div><div class="line">    print_solution(discretization_points, 0, 1, u.data());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The average relative error is &quot;</span></div><div class="line">              &lt;&lt; calculate_error(discretization_points, u.data(), correct_u) /</div><div class="line">                     discretization_points</div><div class="line">              &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
