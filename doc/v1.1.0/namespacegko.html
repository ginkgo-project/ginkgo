<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginkgo: gko Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo_doc.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Ginkgo
   &#160;<span id="projectnumber">Generated from tags/v1.1.0^0 branch based on master. Ginkgo version 1.1.0</span>
   </div>
   <div id="projectbrief">A numerical linear algebra library targeting many-core architectures</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">gko Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Ginkgo namespace.  
<a href="namespacegko.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacegko_1_1accessor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1accessor.html">accessor</a></td></tr>
<tr class="memdesc:namespacegko_1_1accessor"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accessor namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1factorization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1factorization.html">factorization</a></td></tr>
<tr class="memdesc:namespacegko_1_1factorization"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Factorization namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1log"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1log.html">log</a></td></tr>
<tr class="memdesc:namespacegko_1_1log"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logger namespace . <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1matrix"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:namespacegko_1_1matrix"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1name__demangling"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1name__demangling.html">name_demangling</a></td></tr>
<tr class="memdesc:namespacegko_1_1name__demangling"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name demangling namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1preconditioner"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1preconditioner.html">preconditioner</a></td></tr>
<tr class="memdesc:namespacegko_1_1preconditioner"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Preconditioner namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1solver"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1solver.html">solver</a></td></tr>
<tr class="memdesc:namespacegko_1_1solver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ginkgo Solve namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1stop"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1stop.html">stop</a></td></tr>
<tr class="memdesc:namespacegko_1_1stop"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Stopping criterion namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1syn"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1syn.html">syn</a></td></tr>
<tr class="memdesc:namespacegko_1_1syn"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Synthesizer namespace. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegko_1_1xstd"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko_1_1xstd.html">xstd</a></td></tr>
<tr class="memdesc:namespacegko_1_1xstd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The namespace for functionalities after C++11 standard. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1AbstractFactory.html">AbstractFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1AbstractFactory.html" title="The AbstractFactory is a generic interface template that enables easy implementation of the abstract ...">AbstractFactory</a> is a generic interface template that enables easy implementation of the abstract factory design pattern.  <a href="classgko_1_1AbstractFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1AllocationError.html">AllocationError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1AllocationError.html" title="AllocationError is thrown if a memory allocation fails.">AllocationError</a> is thrown if a memory allocation fails.  <a href="classgko_1_1AllocationError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a> is a container which encapsulates fixed-sized arrays, stored on the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> tied to the <a class="el" href="classgko_1_1Array.html" title="An Array is a container which encapsulates fixed-sized arrays, stored on the Executor tied to the Arr...">Array</a>.  <a href="classgko_1_1Array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1BadDimension.html">BadDimension</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1BadDimension.html" title="BadDimension is thrown if an operation is being applied to a LinOp with bad dimensions.">BadDimension</a> is thrown if an operation is being applied to a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> with bad dimensions.  <a href="classgko_1_1BadDimension.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Combination.html">Combination</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Combination.html" title="The Combination class can be used to construct a linear combination of multiple linear operators c1 *...">Combination</a> class can be used to construct a linear combination of multiple linear operators <code>c1 * op1 + c2 * op2 + ... </code> <a href="classgko_1_1Combination.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Composition.html">Composition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Composition.html" title="The Composition class can be used to compose linear operators op1, op2, ..., opn and obtain the opera...">Composition</a> class can be used to compose linear operators <code>op1, op2, ..., opn</code> and obtain the operator <code>op1 * op2 * ... </code> <a href="classgko_1_1Composition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ConvertibleTo.html">ConvertibleTo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1ConvertibleTo.html" title="ConvertibleTo interface is used to mark that the implementer can be converted to the object of Result...">ConvertibleTo</a> interface is used to mark that the implementer can be converted to the object of ResultType.  <a href="classgko_1_1ConvertibleTo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1copy__back__deleter.html">copy_back_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1copy__back__deleter.html" title="A copy_back_deleter is a type of deleter that copies the data to an internally referenced object befo...">copy_back_deleter</a> is a type of deleter that copies the data to an internally referenced object before performing the deletion.  <a href="classgko_1_1copy__back__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1copy__back__deleter_3_01const_01T_01_4.html">copy_back_deleter&lt; const T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CublasError.html">CublasError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CublasError.html" title="CublasError is thrown when a cuBLAS routine throws a non-zero error code.">CublasError</a> is thrown when a cuBLAS routine throws a non-zero error code.  <a href="classgko_1_1CublasError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CudaError.html">CudaError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CudaError.html" title="CudaError is thrown when a CUDA routine throws a non-zero error code.">CudaError</a> is thrown when a CUDA routine throws a non-zero error code.  <a href="classgko_1_1CudaError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CudaExecutor.html">CudaExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents the CUDA device.  <a href="classgko_1_1CudaExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1CusparseError.html">CusparseError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1CusparseError.html" title="CusparseError is thrown when a cuSPARSE routine throws a non-zero error code.">CusparseError</a> is thrown when a cuSPARSE routine throws a non-zero error code.  <a href="classgko_1_1CusparseError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1default__converter.html">default_converter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to convert objects of type <code>S</code> to objects of type <code>R</code> using static_cast.  <a href="structgko_1_1default__converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1dim.html">dim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing the dimensions of a multidimensional object.  <a href="structgko_1_1dim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1dim_3_011u_00_01DimensionType_01_4.html">dim&lt; 1u, DimensionType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1DimensionMismatch.html">DimensionMismatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1DimensionMismatch.html" title="DimensionMismatch is thrown if an operation is being applied to LinOps of incompatible size.">DimensionMismatch</a> is thrown if an operation is being applied to LinOps of incompatible size.  <a href="classgko_1_1DimensionMismatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1enable__parameters__type.html">enable_parameters_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structgko_1_1enable__parameters__type.html" title="The enable_parameters_type mixin is used to create a base implementation of the factory parameters st...">enable_parameters_type</a> mixin is used to create a base implementation of the factory parameters structure.  <a href="structgko_1_1enable__parameters__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableAbstractPolymorphicObject.html">EnableAbstractPolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin inherits from (a subclass of) <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> and provides a base implementation of a new abstract object.  <a href="classgko_1_1EnableAbstractPolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableCreateMethod.html">EnableCreateMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin implements a static <code>create()</code> method on <code>ConcreteType</code> that dynamically allocates the memory, uses the passed-in arguments to construct the object, and returns an std::unique_ptr to such an object.  <a href="classgko_1_1EnableCreateMethod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin provides a default implementation of a concrete factory.  <a href="classgko_1_1EnableDefaultFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnableLinOp.html">EnableLinOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1EnableLinOp.html" title="The EnableLinOp mixin can be used to provide sensible default implementations of the majority of the ...">EnableLinOp</a> mixin can be used to provide sensible default implementations of the majority of the <a class="el" href="classgko_1_1LinOp.html">LinOp</a> and <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> interface.  <a href="classgko_1_1EnableLinOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnablePolymorphicAssignment.html">EnablePolymorphicAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin is used to enable a default <a class="el" href="classgko_1_1PolymorphicObject.html#a5e6f713938293cfbe788d00480eb4d81" title="Copies another object into this object.">PolymorphicObject::copy_from()</a> implementation for objects that have implemented conversions between them.  <a href="classgko_1_1EnablePolymorphicAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1EnablePolymorphicObject.html">EnablePolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mixin inherits from (a subclass of) <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> and provides a base implementation of a new concrete polymorphic object.  <a href="classgko_1_1EnablePolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Error.html">Error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Error.html" title="The Error class is used to report exceptional behaviour in library functions.">Error</a> class is used to report exceptional behaviour in library functions.  <a href="classgko_1_1Error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Executor.html">Executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The first step in using the Ginkgo library consists of creating an executor.  <a href="classgko_1_1Executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1executor__deleter.html">executor_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deleter that uses an executor's <code>free</code> method to deallocate the data.  <a href="classgko_1_1executor__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1executor__deleter_3_01T_0f_0e_4.html">executor_deleter&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1KernelNotFound.html">KernelNotFound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1KernelNotFound.html" title="KernelNotFound is thrown if Ginkgo cannot find a kernel which satisfies the criteria imposed by the i...">KernelNotFound</a> is thrown if Ginkgo cannot find a kernel which satisfies the criteria imposed by the input arguments.  <a href="classgko_1_1KernelNotFound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOp.html">LinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1LinOpFactory.html">LinOpFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a> represents a higher order mapping which transforms one linear operator into another.  <a href="classgko_1_1LinOpFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used as an intermediate data type to store a sparse matrix.  <a href="structgko_1_1matrix__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotCompiled.html">NotCompiled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotCompiled.html" title="NotCompiled is thrown when attempting to call an operation which is a part of a module that was not c...">NotCompiled</a> is thrown when attempting to call an operation which is a part of a module that was not compiled on the system.  <a href="classgko_1_1NotCompiled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotImplemented.html">NotImplemented</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotImplemented.html" title="NotImplemented is thrown in case an operation has not yet been implemented (but will be implemented i...">NotImplemented</a> is thrown in case an operation has not yet been implemented (but will be implemented in the future).  <a href="classgko_1_1NotImplemented.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1NotSupported.html">NotSupported</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a> is thrown in case it is not possible to perform the requested operation on the given object type.  <a href="classgko_1_1NotSupported.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1null__deleter.html">null_deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a deleter that does not delete the object.  <a href="classgko_1_1null__deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1null__deleter_3_01T_0f_0e_4.html">null_deleter&lt; T[]&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1OmpExecutor.html">OmpExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> subclass which represents the OpenMP device (typically CPU).  <a href="classgko_1_1OmpExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations can be used to define functionalities whose implementations differ among devices.  <a href="classgko_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1OutOfBoundsError.html">OutOfBoundsError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1OutOfBoundsError.html" title="OutOfBoundsError is thrown if a memory access is detected to be out-of-bounds.">OutOfBoundsError</a> is thrown if a memory access is detected to be out-of-bounds.  <a href="classgko_1_1OutOfBoundsError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Perturbation.html">Perturbation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classgko_1_1Perturbation.html" title="The Perturbation class can be used to construct a LinOp to represent the operation (identity + scalar...">Perturbation</a> class can be used to construct a <a class="el" href="classgko_1_1LinOp.html">LinOp</a> to represent the operation <code>(identity + scalar * basis * projector)</code>.  <a href="classgko_1_1Perturbation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1PolymorphicObject.html">PolymorphicObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1PolymorphicObject.html" title="A PolymorphicObject is the abstract base for all &quot;heavy&quot; objects in Ginkgo that behave polymorphicall...">PolymorphicObject</a> is the abstract base for all "heavy" objects in Ginkgo that behave polymorphically.  <a href="classgko_1_1PolymorphicObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to encode storage precisions of low precision algorithms.  <a href="classgko_1_1precision__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Preconditionable.html">Preconditionable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can be preconditioned.  <a href="classgko_1_1Preconditionable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range is a multidimensional view of the memory.  <a href="classgko_1_1range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReadableFromMatrixData.html">ReadableFromMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can read its data from a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1ReadableFromMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1ReferenceExecutor.html">ReferenceExecutor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a specialization of the <a class="el" href="classgko_1_1OmpExecutor.html" title="This is the Executor subclass which represents the OpenMP device (typically CPU).">OmpExecutor</a>, which runs the reference implementations of the kernels used for debugging purposes.  <a href="classgko_1_1ReferenceExecutor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1span.html">span</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A span is a lightweight structure used to create sub-ranges from other ranges.  <a href="structgko_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1stopping__status.html">stopping_status</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to keep track of the stopping status of one vector.  <a href="classgko_1_1stopping__status.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1StreamError.html">StreamError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classgko_1_1StreamError.html" title="StreamError is thrown if accessing a stream failed.">StreamError</a> is thrown if accessing a stream failed.  <a href="classgko_1_1StreamError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1temporary__clone.html">temporary_clone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1temporary__clone.html" title="A temporary_clone is a special smart pointer-like object that is designed to hold an object temporari...">temporary_clone</a> is a special smart pointer-like object that is designed to hold an object temporarily copied to another executor.  <a href="classgko_1_1temporary__clone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1Transposable.html">Transposable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear operators which support transposition should implement the <a class="el" href="classgko_1_1Transposable.html" title="Linear operators which support transposition should implement the Transposable interface.">Transposable</a> interface.  <a href="classgko_1_1Transposable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1truncated.html">truncated</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structgko_1_1version.html">version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure is used to represent versions of various Ginkgo modules.  <a href="structgko_1_1version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1version__info.html">version_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ginkgo uses version numbers to label new features and to communicate backward compatibility guarantees:  <a href="classgko_1_1version__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgko_1_1WritableToMatrixData.html">WritableToMatrixData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classgko_1_1LinOp.html">LinOp</a> implementing this interface can write its data to a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure.  <a href="classgko_1_1WritableToMatrixData.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteFactory , typename ConcreteLinOp , typename ParametersType , typename PolymorphicBase  = LinOpFactory&gt; </td></tr>
<tr class="memitem:ga24628d477cba68b31cea690572c51912"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">EnableDefaultLinOpFactory</a> = <a class="el" href="classgko_1_1EnableDefaultFactory.html">EnableDefaultFactory</a>&lt; ConcreteFactory, ConcreteLinOp, ParametersType, PolymorphicBase &gt;</td></tr>
<tr class="memdesc:ga24628d477cba68b31cea690572c51912"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an alias for the <a class="el" href="classgko_1_1EnableDefaultFactory.html" title="This mixin provides a default implementation of a concrete factory.">EnableDefaultFactory</a> mixin, which correctly sets the template parameters to enable a subclass of <a class="el" href="classgko_1_1LinOpFactory.html" title="A LinOpFactory represents a higher order mapping which transforms one linear operator into another.">LinOpFactory</a>.  <a href="group__LinOp.html#ga24628d477cba68b31cea690572c51912">More...</a><br /></td></tr>
<tr class="separator:ga24628d477cba68b31cea690572c51912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcb75c44f6b6c701989419c166f6e7e"><td class="memTemplParams" colspan="2"><a id="adfcb75c44f6b6c701989419c166f6e7e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfcb75c44f6b6c701989419c166f6e7e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#adfcb75c44f6b6c701989419c166f6e7e">remove_complex</a> = typename detail::remove_complex_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:adfcb75c44f6b6c701989419c166f6e7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a real counterpart of a std::complex type, and leaves the type unchanged if it is not a complex type. <br /></td></tr>
<tr class="separator:adfcb75c44f6b6c701989419c166f6e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeede19206954d5c8ebd04c95cf63bb88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeede19206954d5c8ebd04c95cf63bb88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a> = detail::is_complex_impl&lt; T &gt;</td></tr>
<tr class="memdesc:aeede19206954d5c8ebd04c95cf63bb88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to check if T is a complex value during compile time by accessing the <code>value</code> attribute of this struct.  <a href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">More...</a><br /></td></tr>
<tr class="separator:aeede19206954d5c8ebd04c95cf63bb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memTemplParams" colspan="2"><a id="ab5d71c1f4bd1b654df1e561ea7a811f2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a> = typename detail::reduce_precision_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next type in the hierarchy with lower precision than T. <br /></td></tr>
<tr class="separator:ab5d71c1f4bd1b654df1e561ea7a811f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c2b4782d95e675d7e91a75bab101d"><td class="memTemplParams" colspan="2"><a id="a373c2b4782d95e675d7e91a75bab101d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373c2b4782d95e675d7e91a75bab101d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a> = typename detail::increase_precision_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:a373c2b4782d95e675d7e91a75bab101d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains the next type in the hierarchy with higher precision than T. <br /></td></tr>
<tr class="separator:a373c2b4782d95e675d7e91a75bab101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf540a6830b3ac4cd6b193133510f4d7"><td class="memTemplParams" colspan="2"><a id="abf540a6830b3ac4cd6b193133510f4d7"></a>
template&lt;typename T , size_type Limit = sizeof(uint16) * byte_size&gt; </td></tr>
<tr class="memitem:abf540a6830b3ac4cd6b193133510f4d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#abf540a6830b3ac4cd6b193133510f4d7">truncate_type</a> = xstd::conditional_t&lt; detail::type_size_impl&lt; T &gt;::value &gt;=2 *Limit, typename detail::truncate_type_impl&lt; T &gt;::type, T &gt;</td></tr>
<tr class="memdesc:abf540a6830b3ac4cd6b193133510f4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncates the type by half (by dropping bits), but ensures that it is at least <code>Limit</code> bits wide. <br /></td></tr>
<tr class="separator:abf540a6830b3ac4cd6b193133510f4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="memItemLeft" align="right" valign="top"><a id="a6e5c95df0ae4e47aab2f604a22d98ee7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integral type used for allocation quantities. <br /></td></tr>
<tr class="separator:a6e5c95df0ae4e47aab2f604a22d98ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="memItemLeft" align="right" valign="top"><a id="ad7a8c26c7cb547663bff3cc1df3c8db0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad7a8c26c7cb547663bff3cc1df3c8db0">int8</a> = std::int8_t</td></tr>
<tr class="memdesc:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit signed integral type. <br /></td></tr>
<tr class="separator:ad7a8c26c7cb547663bff3cc1df3c8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="memItemLeft" align="right" valign="top"><a id="a26d2e6df1a5280b092afd1e5d9fabeed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a26d2e6df1a5280b092afd1e5d9fabeed">int16</a> = std::int16_t</td></tr>
<tr class="memdesc:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit signed integral type. <br /></td></tr>
<tr class="separator:a26d2e6df1a5280b092afd1e5d9fabeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec26caa2379a21a8d0cde611559fff6"><td class="memItemLeft" align="right" valign="top"><a id="a1ec26caa2379a21a8d0cde611559fff6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1ec26caa2379a21a8d0cde611559fff6">int32</a> = std::int32_t</td></tr>
<tr class="memdesc:a1ec26caa2379a21a8d0cde611559fff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit signed integral type. <br /></td></tr>
<tr class="separator:a1ec26caa2379a21a8d0cde611559fff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="memItemLeft" align="right" valign="top"><a id="a6c57dbf3168b1ecad3ea133aaf2efbc1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> = std::int64_t</td></tr>
<tr class="memdesc:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit signed integral type. <br /></td></tr>
<tr class="separator:a6c57dbf3168b1ecad3ea133aaf2efbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3950fc3732811a8563484e5098c31531"><td class="memItemLeft" align="right" valign="top"><a id="a3950fc3732811a8563484e5098c31531"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3950fc3732811a8563484e5098c31531">uint8</a> = std::uint8_t</td></tr>
<tr class="memdesc:a3950fc3732811a8563484e5098c31531"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit unsigned integral type. <br /></td></tr>
<tr class="separator:a3950fc3732811a8563484e5098c31531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb8517627d37e0c4ff4f39a5303a795"><td class="memItemLeft" align="right" valign="top"><a id="afdb8517627d37e0c4ff4f39a5303a795"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#afdb8517627d37e0c4ff4f39a5303a795">uint16</a> = std::uint16_t</td></tr>
<tr class="memdesc:afdb8517627d37e0c4ff4f39a5303a795"><td class="mdescLeft">&#160;</td><td class="mdescRight">16-bit unsigned integral type. <br /></td></tr>
<tr class="separator:afdb8517627d37e0c4ff4f39a5303a795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c831e3fe269ba04c6ed8bf5a71073"><td class="memItemLeft" align="right" valign="top"><a id="a318c831e3fe269ba04c6ed8bf5a71073"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> = std::uint32_t</td></tr>
<tr class="memdesc:a318c831e3fe269ba04c6ed8bf5a71073"><td class="mdescLeft">&#160;</td><td class="mdescRight">32-bit unsigned integral type. <br /></td></tr>
<tr class="separator:a318c831e3fe269ba04c6ed8bf5a71073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a79afecd57aabbb04b1dc611ae55e"><td class="memItemLeft" align="right" valign="top"><a id="ad54a79afecd57aabbb04b1dc611ae55e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad54a79afecd57aabbb04b1dc611ae55e">uint64</a> = std::uint64_t</td></tr>
<tr class="memdesc:ad54a79afecd57aabbb04b1dc611ae55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">64-bit unsigned integral type. <br /></td></tr>
<tr class="separator:ad54a79afecd57aabbb04b1dc611ae55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0913bfb81622f6bdde52884015c2a4ed"><td class="memItemLeft" align="right" valign="top"><a id="a0913bfb81622f6bdde52884015c2a4ed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>uintptr</b> = std::uintptr_t</td></tr>
<tr class="separator:a0913bfb81622f6bdde52884015c2a4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86477c0acba18c50cac69112d791dfa6"><td class="memItemLeft" align="right" valign="top"><a id="a86477c0acba18c50cac69112d791dfa6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a86477c0acba18c50cac69112d791dfa6">float16</a> = half</td></tr>
<tr class="memdesc:a86477c0acba18c50cac69112d791dfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Half precision floating point type. <br /></td></tr>
<tr class="separator:a86477c0acba18c50cac69112d791dfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="memItemLeft" align="right" valign="top"><a id="a0b5dbd886493d4ccaba6a7a1ba74896c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0b5dbd886493d4ccaba6a7a1ba74896c">float32</a> = float</td></tr>
<tr class="memdesc:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single precision floating point type. <br /></td></tr>
<tr class="separator:a0b5dbd886493d4ccaba6a7a1ba74896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="memItemLeft" align="right" valign="top"><a id="a75c7a433d814b8b37d0bc2a9c57fbe65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a75c7a433d814b8b37d0bc2a9c57fbe65">float64</a> = double</td></tr>
<tr class="memdesc:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Double precision floating point type. <br /></td></tr>
<tr class="separator:a75c7a433d814b8b37d0bc2a9c57fbe65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3257beda99ac9180b501912be5caa5f"><td class="memItemLeft" align="right" valign="top"><a id="ae3257beda99ac9180b501912be5caa5f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae3257beda99ac9180b501912be5caa5f">full_precision</a> = double</td></tr>
<tr class="memdesc:ae3257beda99ac9180b501912be5caa5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The most precise floating-point type. <br /></td></tr>
<tr class="separator:ae3257beda99ac9180b501912be5caa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="memItemLeft" align="right" valign="top"><a id="a1d44e117d2f74b34bdc83ac5c0c6b605"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1d44e117d2f74b34bdc83ac5c0c6b605">default_precision</a> = double</td></tr>
<tr class="memdesc:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Precision used if no precision is explicitly specified. <br /></td></tr>
<tr class="separator:a1d44e117d2f74b34bdc83ac5c0c6b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> { <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a>, 
<a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af5d7aa3ba4929cc12dc51a92c59fabd3">layout_type::coordinate</a>
 }</td></tr>
<tr class="memdesc:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the layout type when writing data in matrix market format.  <a href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">More...</a><br /></td></tr>
<tr class="separator:ae749a5ea11a93c1bcc9158d9a6e9fb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a74c3716da36cbedc000aa24006b0bd46"><td class="memTemplParams" colspan="2">template&lt;size_type Dimensionality, typename DimensionType &gt; </td></tr>
<tr class="memitem:a74c3716da36cbedc000aa24006b0bd46"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a74c3716da36cbedc000aa24006b0bd46">operator!=</a> (const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;x, const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;y)</td></tr>
<tr class="memdesc:a74c3716da36cbedc000aa24006b0bd46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two dim objects are different.  <a href="namespacegko.html#a74c3716da36cbedc000aa24006b0bd46">More...</a><br /></td></tr>
<tr class="separator:a74c3716da36cbedc000aa24006b0bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memTemplParams" colspan="2">template&lt;typename DimensionType &gt; </td></tr>
<tr class="memitem:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9b6a9d7018703d6d1f2140054e2afe4a">transpose</a> (const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt; &amp;dimensions) noexcept</td></tr>
<tr class="memdesc:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped.  <a href="namespacegko.html#a9b6a9d7018703d6d1f2140054e2afe4a">More...</a><br /></td></tr>
<tr class="separator:a9b6a9d7018703d6d1f2140054e2afe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3e79911bb6145d7ba865dbe436b915"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b3e79911bb6145d7ba865dbe436b915"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9b3e79911bb6145d7ba865dbe436b915">is_complex</a> ()</td></tr>
<tr class="memdesc:a9b3e79911bb6145d7ba865dbe436b915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if T is a complex type.  <a href="namespacegko.html#a9b3e79911bb6145d7ba865dbe436b915">More...</a><br /></td></tr>
<tr class="separator:a9b3e79911bb6145d7ba865dbe436b915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c197f1db98fdc874f8907978ad114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5f9c197f1db98fdc874f8907978ad114"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a5f9c197f1db98fdc874f8907978ad114">round_down</a> (T val)</td></tr>
<tr class="memdesc:a5f9c197f1db98fdc874f8907978ad114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces the precision of the input parameter.  <a href="namespacegko.html#a5f9c197f1db98fdc874f8907978ad114">More...</a><br /></td></tr>
<tr class="separator:a5f9c197f1db98fdc874f8907978ad114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad45d1c855f31d2f8c1d3d799f2cf21c6">round_up</a> (T val)</td></tr>
<tr class="memdesc:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the precision of the input parameter.  <a href="namespacegko.html#ad45d1c855f31d2f8c1d3d799f2cf21c6">More...</a><br /></td></tr>
<tr class="separator:ad45d1c855f31d2f8c1d3d799f2cf21c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93065a86872e6511b701b73b75823483"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a93065a86872e6511b701b73b75823483">ceildiv</a> (<a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> num, <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> den)</td></tr>
<tr class="memdesc:a93065a86872e6511b701b73b75823483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs integer division with rounding up.  <a href="namespacegko.html#a93065a86872e6511b701b73b75823483">More...</a><br /></td></tr>
<tr class="separator:a93065a86872e6511b701b73b75823483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5">zero</a> ()</td></tr>
<tr class="memdesc:a70dbe01ff95c7b953d3d737424c6feb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the additive identity for T.  <a href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5">More...</a><br /></td></tr>
<tr class="separator:a70dbe01ff95c7b953d3d737424c6feb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9f1cd7be946b9a2c15b01b744cf3e732">zero</a> (const T &amp;)</td></tr>
<tr class="memdesc:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the additive identity for T.  <a href="namespacegko.html#a9f1cd7be946b9a2c15b01b744cf3e732">More...</a><br /></td></tr>
<tr class="separator:a9f1cd7be946b9a2c15b01b744cf3e732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">one</a> ()</td></tr>
<tr class="memdesc:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicative identity for T.  <a href="namespacegko.html#a0059e27f8f4bc348ff65c1e60caf47c8">More...</a><br /></td></tr>
<tr class="separator:a0059e27f8f4bc348ff65c1e60caf47c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab4f16ecf0a759f46259cf9518f1e4568">one</a> (const T &amp;)</td></tr>
<tr class="memdesc:ab4f16ecf0a759f46259cf9518f1e4568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the multiplicative identity for T.  <a href="namespacegko.html#ab4f16ecf0a759f46259cf9518f1e4568">More...</a><br /></td></tr>
<tr class="separator:ab4f16ecf0a759f46259cf9518f1e4568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57797fc0a00fd4b7ff34ca4bfc84bc51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57797fc0a00fd4b7ff34ca4bfc84bc51"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">abs</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a57797fc0a00fd4b7ff34ca4bfc84bc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of the object.  <a href="namespacegko.html#a57797fc0a00fd4b7ff34ca4bfc84bc51">More...</a><br /></td></tr>
<tr class="separator:a57797fc0a00fd4b7ff34ca4bfc84bc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1812df45c6ec07780d579a12b64c753"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af1812df45c6ec07780d579a12b64c753"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#af1812df45c6ec07780d579a12b64c753">max</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:af1812df45c6ec07780d579a12b64c753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the larger of the arguments.  <a href="namespacegko.html#af1812df45c6ec07780d579a12b64c753">More...</a><br /></td></tr>
<tr class="separator:af1812df45c6ec07780d579a12b64c753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf8487194bcb40b528969c187a413a0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaaf8487194bcb40b528969c187a413a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aaaf8487194bcb40b528969c187a413a0">min</a> (const T &amp;x, const T &amp;y)</td></tr>
<tr class="memdesc:aaaf8487194bcb40b528969c187a413a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smaller of the arguments.  <a href="namespacegko.html#aaaf8487194bcb40b528969c187a413a0">More...</a><br /></td></tr>
<tr class="separator:aaaf8487194bcb40b528969c187a413a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23cfd886cee6e88d77bcbbbe1928b78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae23cfd886cee6e88d77bcbbbe1928b78"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae23cfd886cee6e88d77bcbbbe1928b78">real</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae23cfd886cee6e88d77bcbbbe1928b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the real part of the object.  <a href="namespacegko.html#ae23cfd886cee6e88d77bcbbbe1928b78">More...</a><br /></td></tr>
<tr class="separator:ae23cfd886cee6e88d77bcbbbe1928b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff1061513b10ccd5122015d2e5f9faa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ff1061513b10ccd5122015d2e5f9faa"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a7ff1061513b10ccd5122015d2e5f9faa">imag</a> (const T &amp;)</td></tr>
<tr class="memdesc:a7ff1061513b10ccd5122015d2e5f9faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the imaginary part of the object.  <a href="namespacegko.html#a7ff1061513b10ccd5122015d2e5f9faa">More...</a><br /></td></tr>
<tr class="separator:a7ff1061513b10ccd5122015d2e5f9faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaec5c4f959a948a6d0f3e99a57c7ea"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdaec5c4f959a948a6d0f3e99a57c7ea"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#acdaec5c4f959a948a6d0f3e99a57c7ea">conj</a> (const T &amp;x)</td></tr>
<tr class="memdesc:acdaec5c4f959a948a6d0f3e99a57c7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the conjugate of an object.  <a href="namespacegko.html#acdaec5c4f959a948a6d0f3e99a57c7ea">More...</a><br /></td></tr>
<tr class="separator:acdaec5c4f959a948a6d0f3e99a57c7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb55709b10d707b2cbef803832aa834"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abbb55709b10d707b2cbef803832aa834"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm</a> (const T &amp;x) -&gt; decltype(<a class="el" href="namespacegko.html#ae23cfd886cee6e88d77bcbbbe1928b78">real</a>(<a class="el" href="namespacegko.html#acdaec5c4f959a948a6d0f3e99a57c7ea">conj</a>(x) *x))</td></tr>
<tr class="memdesc:abbb55709b10d707b2cbef803832aa834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared norm of the object.  <a href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">More...</a><br /></td></tr>
<tr class="separator:abbb55709b10d707b2cbef803832aa834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4eea40e4123a3fdb60fcd92f902c6d6d">get_significant_bit</a> (const T &amp;n, <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> hint=0u) noexcept</td></tr>
<tr class="memdesc:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the most significant bit of the number.  <a href="namespacegko.html#a4eea40e4123a3fdb60fcd92f902c6d6d">More...</a><br /></td></tr>
<tr class="separator:a4eea40e4123a3fdb60fcd92f902c6d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39645fe8148a8a812a9528865a77600"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad39645fe8148a8a812a9528865a77600"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad39645fe8148a8a812a9528865a77600">get_superior_power</a> (const T &amp;base, const T &amp;limit, const T &amp;hint=T{1}) noexcept</td></tr>
<tr class="memdesc:ad39645fe8148a8a812a9528865a77600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the smallest power of <code>base</code> not smaller than <code>limit</code>.  <a href="namespacegko.html#ad39645fe8148a8a812a9528865a77600">More...</a><br /></td></tr>
<tr class="separator:ad39645fe8148a8a812a9528865a77600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a34246f622b7e45cd5e40dc7f1f16e"><td class="memTemplParams" colspan="2"><a id="a23a34246f622b7e45cd5e40dc7f1f16e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23a34246f622b7e45cd5e40dc7f1f16e"><td class="memTemplItemLeft" align="right" valign="top">xstd::enable_if_t&lt;!<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isfinite</b> (const T &amp;value)</td></tr>
<tr class="separator:a23a34246f622b7e45cd5e40dc7f1f16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0f20b5d373f9439702e723d48548fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb0f20b5d373f9439702e723d48548fa"><td class="memTemplItemLeft" align="right" valign="top">xstd::enable_if_t&lt; <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#afb0f20b5d373f9439702e723d48548fa">isfinite</a> (const T &amp;value)</td></tr>
<tr class="memdesc:afb0f20b5d373f9439702e723d48548fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all components of a complex value are finite, meaning they are neither +/- infinity nor NaN.  <a href="namespacegko.html#afb0f20b5d373f9439702e723d48548fa">More...</a><br /></td></tr>
<tr class="separator:afb0f20b5d373f9439702e723d48548fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b476e0e3df616b08efe85000bff8da0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </td></tr>
<tr class="memitem:a0b476e0e3df616b08efe85000bff8da0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">read_raw</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:a0b476e0e3df616b08efe85000bff8da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in matrix market format from an input stream.  <a href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">More...</a><br /></td></tr>
<tr class="separator:a0b476e0e3df616b08efe85000bff8da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename IndexType &gt; </td></tr>
<tr class="memitem:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">write_raw</a> (std::ostream &amp;os, const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;data, <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> layout=<a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a>)</td></tr>
<tr class="memdesc:ab31feb99c64fc6df58ac09abd4af69b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in matrix market format.  <a href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">More...</a><br /></td></tr>
<tr class="separator:ab31feb99c64fc6df58ac09abd4af69b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </td></tr>
<tr class="memitem:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; MatrixType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">read</a> (StreamType &amp;&amp;is, MatrixArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a92cf0178c1c55419d32d2bb527e57e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in matrix market format from an input stream.  <a href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">More...</a><br /></td></tr>
<tr class="separator:a92cf0178c1c55419d32d2bb527e57e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859dc47a462721d83728d91ab7fa2148"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename StreamType &gt; </td></tr>
<tr class="memitem:a859dc47a462721d83728d91ab7fa2148"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a859dc47a462721d83728d91ab7fa2148">write</a> (StreamType &amp;&amp;os, MatrixType *matrix, <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a> layout=<a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a>)</td></tr>
<tr class="memdesc:a859dc47a462721d83728d91ab7fa2148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a matrix stored in matrix market format from an input stream.  <a href="namespacegko.html#a859dc47a462721d83728d91ab7fa2148">More...</a><br /></td></tr>
<tr class="separator:a859dc47a462721d83728d91ab7fa2148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cef6e5e9e02b8d77ce01be41117cc0"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:ac5cef6e5e9e02b8d77ce01be41117cc0"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; R, std::function&lt; void(R *)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ac5cef6e5e9e02b8d77ce01be41117cc0">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, T *obj)</td></tr>
<tr class="memdesc:ac5cef6e5e9e02b8d77ce01be41117cc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#ac5cef6e5e9e02b8d77ce01be41117cc0">More...</a><br /></td></tr>
<tr class="separator:ac5cef6e5e9e02b8d77ce01be41117cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add859060efaa729c84788bb4f6582e9f"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:add859060efaa729c84788bb4f6582e9f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; const R, std::function&lt; void(const R *)&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#add859060efaa729c84788bb4f6582e9f">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const T *obj)</td></tr>
<tr class="memdesc:add859060efaa729c84788bb4f6582e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#add859060efaa729c84788bb4f6582e9f">More...</a><br /></td></tr>
<tr class="separator:add859060efaa729c84788bb4f6582e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#ac2b925f8d9f288210c7d1f0e00e5c495">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, std::shared_ptr&lt; T &gt; obj)</td></tr>
<tr class="memdesc:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec.  <a href="namespacegko.html#ac2b925f8d9f288210c7d1f0e00e5c495">More...</a><br /></td></tr>
<tr class="separator:ac2b925f8d9f288210c7d1f0e00e5c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f28847393e540a33fdda8cd80584789"><td class="memTemplParams" colspan="2">template&lt;typename R , typename T &gt; </td></tr>
<tr class="memitem:a0f28847393e540a33fdda8cd80584789"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const R &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a0f28847393e540a33fdda8cd80584789">copy_and_convert_to</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, std::shared_ptr&lt; const T &gt; obj)</td></tr>
<tr class="separator:a0f28847393e540a33fdda8cd80584789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cd8a74bb04c04ba81d88de0d0677b2"><td class="memItemLeft" align="right" valign="top"><a id="a22cd8a74bb04c04ba81d88de0d0677b2"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:a22cd8a74bb04c04ba81d88de0d0677b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece8127f67d50be468da56463320819f"><td class="memItemLeft" align="right" valign="top"><a id="aece8127f67d50be468da56463320819f"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:aece8127f67d50be468da56463320819f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec3871dd48b1b7abd345404fc5fea4"><td class="memItemLeft" align="right" valign="top"><a id="abfec3871dd48b1b7abd345404fc5fea4"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:abfec3871dd48b1b7abd345404fc5fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a579660b1a1d65b353ede9ab691730"><td class="memItemLeft" align="right" valign="top"><a id="af6a579660b1a1d65b353ede9ab691730"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:af6a579660b1a1d65b353ede9ab691730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4fd5d9324b20d7205d3cc6ab610444"><td class="memItemLeft" align="right" valign="top"><a id="afa4fd5d9324b20d7205d3cc6ab610444"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:afa4fd5d9324b20d7205d3cc6ab610444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b572cdf444e58282049b6eeed87f0a"><td class="memItemLeft" align="right" valign="top"><a id="a76b572cdf444e58282049b6eeed87f0a"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structgko_1_1span.html">span</a> &amp;first, const <a class="el" href="structgko_1_1span.html">span</a> &amp;second)</td></tr>
<tr class="separator:a76b572cdf444e58282049b6eeed87f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memTemplParams" colspan="2"><a id="ac794f6c0cb0e1252d2326feebae6ba56"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1unary__plus.html">accessor::unary_plus</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ac794f6c0cb0e1252d2326feebae6ba56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb7f55a089dea8a02ce13d570894253"><td class="memTemplParams" colspan="2"><a id="acdb7f55a089dea8a02ce13d570894253"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:acdb7f55a089dea8a02ce13d570894253"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1unary__minus.html">accessor::unary_minus</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:acdb7f55a089dea8a02ce13d570894253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memTemplParams" colspan="2"><a id="a1b0174e1e36ef6c8561108174e35a1b6"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__not.html">accessor::logical_not</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a1b0174e1e36ef6c8561108174e35a1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69778756c37d99881afbd0ec6203db60"><td class="memTemplParams" colspan="2"><a id="a69778756c37d99881afbd0ec6203db60"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a69778756c37d99881afbd0ec6203db60"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__not.html">accessor::bitwise_not</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator~</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a69778756c37d99881afbd0ec6203db60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6313c0993fea961ebefddb393ab937d"><td class="memTemplParams" colspan="2"><a id="ae6313c0993fea961ebefddb393ab937d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ae6313c0993fea961ebefddb393ab937d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1zero__operation.html">accessor::zero_operation</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>zero</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ae6313c0993fea961ebefddb393ab937d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314483c618b92c78dc6ac2e978ad4529"><td class="memTemplParams" colspan="2"><a id="a314483c618b92c78dc6ac2e978ad4529"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a314483c618b92c78dc6ac2e978ad4529"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1one__operaton.html">accessor::one_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>one</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a314483c618b92c78dc6ac2e978ad4529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1affadd93ed2a2b867d5aeff319e8922"><td class="memTemplParams" colspan="2"><a id="a1affadd93ed2a2b867d5aeff319e8922"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1affadd93ed2a2b867d5aeff319e8922"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1abs__operaton.html">accessor::abs_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a1affadd93ed2a2b867d5aeff319e8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memTemplParams" colspan="2"><a id="ac1abf93b0d48330b1d2dad93a30f7a67"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1real__operaton.html">accessor::real_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ac1abf93b0d48330b1d2dad93a30f7a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memTemplParams" colspan="2"><a id="ae11c76be937a8bf8393f4c1c27702dc0"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1imag__operaton.html">accessor::imag_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:ae11c76be937a8bf8393f4c1c27702dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memTemplParams" colspan="2"><a id="a5d217879d3f2759a2020e2ff5bbb2eca"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1conj__operaton.html">accessor::conj_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:a5d217879d3f2759a2020e2ff5bbb2eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf85875a944e6e03c8427d3790e568c1"><td class="memTemplParams" colspan="2"><a id="aaf85875a944e6e03c8427d3790e568c1"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aaf85875a944e6e03c8427d3790e568c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1squared__norm__operaton.html">accessor::squared_norm_operaton</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>squared_norm</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:aaf85875a944e6e03c8427d3790e568c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d61bb1d045d3cc21add96cd565cb56"><td class="memTemplParams" colspan="2"><a id="af0d61bb1d045d3cc21add96cd565cb56"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af0d61bb1d045d3cc21add96cd565cb56"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1transpose__operation.html">accessor::transpose_operation</a>&lt; Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;operand)</td></tr>
<tr class="separator:af0d61bb1d045d3cc21add96cd565cb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1313bcbb37e83bf24a111edfebb83e44"><td class="memTemplParams" colspan="2"><a id="a1313bcbb37e83bf24a111edfebb83e44"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a1313bcbb37e83bf24a111edfebb83e44"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a1313bcbb37e83bf24a111edfebb83e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d04205743fc18e740caee6b8cb8720c"><td class="memTemplParams" colspan="2"><a id="a0d04205743fc18e740caee6b8cb8720c"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a0d04205743fc18e740caee6b8cb8720c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a0d04205743fc18e740caee6b8cb8720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2193faa27b6fcc5c7220923141a3ad"><td class="memTemplParams" colspan="2"><a id="add2193faa27b6fcc5c7220923141a3ad"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:add2193faa27b6fcc5c7220923141a3ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:add2193faa27b6fcc5c7220923141a3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15048e6bc74da6120729e407b5c74f30"><td class="memTemplParams" colspan="2"><a id="a15048e6bc74da6120729e407b5c74f30"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a15048e6bc74da6120729e407b5c74f30"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1add.html">accessor::add</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a15048e6bc74da6120729e407b5c74f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c773c140e30d751bbf8826c2faf4f74"><td class="memTemplParams" colspan="2"><a id="a4c773c140e30d751bbf8826c2faf4f74"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a4c773c140e30d751bbf8826c2faf4f74"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a4c773c140e30d751bbf8826c2faf4f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f88660f5606ed9da1c156bb7139b6"><td class="memTemplParams" colspan="2"><a id="ae46f88660f5606ed9da1c156bb7139b6"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ae46f88660f5606ed9da1c156bb7139b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ae46f88660f5606ed9da1c156bb7139b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memTemplParams" colspan="2"><a id="a4d778fb0a4dd79be3297adea7a8b4e31"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a4d778fb0a4dd79be3297adea7a8b4e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e9697a7f202cdfef1016e535e2568"><td class="memTemplParams" colspan="2"><a id="a5d0e9697a7f202cdfef1016e535e2568"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a5d0e9697a7f202cdfef1016e535e2568"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1sub.html">accessor::sub</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a5d0e9697a7f202cdfef1016e535e2568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2723c0333fc2349178c8bd33a13d72b8"><td class="memTemplParams" colspan="2"><a id="a2723c0333fc2349178c8bd33a13d72b8"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a2723c0333fc2349178c8bd33a13d72b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a2723c0333fc2349178c8bd33a13d72b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3c1ce84d54e93c170a0a993434349"><td class="memTemplParams" colspan="2"><a id="a86b3c1ce84d54e93c170a0a993434349"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a86b3c1ce84d54e93c170a0a993434349"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a86b3c1ce84d54e93c170a0a993434349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memTemplParams" colspan="2"><a id="a1cb48dd84f149784a1b8827d5cc1a190"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a1cb48dd84f149784a1b8827d5cc1a190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fb75dc070c4ea51828628aeec144cc"><td class="memTemplParams" colspan="2"><a id="aa2fb75dc070c4ea51828628aeec144cc"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa2fb75dc070c4ea51828628aeec144cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mul.html">accessor::mul</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa2fb75dc070c4ea51828628aeec144cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c291b8175c3a41649bdfdfde9d7485"><td class="memTemplParams" colspan="2"><a id="a83c291b8175c3a41649bdfdfde9d7485"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a83c291b8175c3a41649bdfdfde9d7485"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a83c291b8175c3a41649bdfdfde9d7485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memTemplParams" colspan="2"><a id="a40c33c78a06d2e2bae92f7f1cc254a3e"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a40c33c78a06d2e2bae92f7f1cc254a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b921aed556c1773376ad2feb082fafb"><td class="memTemplParams" colspan="2"><a id="a3b921aed556c1773376ad2feb082fafb"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a3b921aed556c1773376ad2feb082fafb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a3b921aed556c1773376ad2feb082fafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad617073f36809325a11db56fc66d433e"><td class="memTemplParams" colspan="2"><a id="ad617073f36809325a11db56fc66d433e"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ad617073f36809325a11db56fc66d433e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1div.html">accessor::div</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ad617073f36809325a11db56fc66d433e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcbe4818e5316566e04afa5d653ec23"><td class="memTemplParams" colspan="2"><a id="aabcbe4818e5316566e04afa5d653ec23"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aabcbe4818e5316566e04afa5d653ec23"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:aabcbe4818e5316566e04afa5d653ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02261bf3b7594d48bb51093593896e1"><td class="memTemplParams" colspan="2"><a id="af02261bf3b7594d48bb51093593896e1"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af02261bf3b7594d48bb51093593896e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af02261bf3b7594d48bb51093593896e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175e929e92316d5352207795a0da2a82"><td class="memTemplParams" colspan="2"><a id="a175e929e92316d5352207795a0da2a82"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a175e929e92316d5352207795a0da2a82"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a175e929e92316d5352207795a0da2a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memTemplParams" colspan="2"><a id="abe20522bc3e2a9e6f1069d783cad8e06"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mod.html">accessor::mod</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator%</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:abe20522bc3e2a9e6f1069d783cad8e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86394e93b6c232aae4816b59bdcca96"><td class="memTemplParams" colspan="2"><a id="ab86394e93b6c232aae4816b59bdcca96"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:ab86394e93b6c232aae4816b59bdcca96"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:ab86394e93b6c232aae4816b59bdcca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memTemplParams" colspan="2"><a id="ae8b90df104f6069d07d0d7a81a21d1de"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ae8b90df104f6069d07d0d7a81a21d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memTemplParams" colspan="2"><a id="a06e29cc3ae776a00c79b7a3b8fdf2ef9"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a06e29cc3ae776a00c79b7a3b8fdf2ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4f898ac5f7d9aedbabd1b361943982"><td class="memTemplParams" colspan="2"><a id="afe4f898ac5f7d9aedbabd1b361943982"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:afe4f898ac5f7d9aedbabd1b361943982"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less.html">accessor::less</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:afe4f898ac5f7d9aedbabd1b361943982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memTemplParams" colspan="2"><a id="af2fc01ef12bf15ea7da4c14d98e55cc7"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:af2fc01ef12bf15ea7da4c14d98e55cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memTemplParams" colspan="2"><a id="a3f0ff2b60791b5cc3bab79fa91ab46f8"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a3f0ff2b60791b5cc3bab79fa91ab46f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memTemplParams" colspan="2"><a id="a3d7af1edcc3719e52f0f3b9519651d2d"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a3d7af1edcc3719e52f0f3b9519651d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memTemplParams" colspan="2"><a id="a8ea0e27f2e5baab0c073e4e6baff4b7e"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater.html">accessor::greater</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a8ea0e27f2e5baab0c073e4e6baff4b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41355e557a67620659b116f79ba7074d"><td class="memTemplParams" colspan="2"><a id="a41355e557a67620659b116f79ba7074d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a41355e557a67620659b116f79ba7074d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a41355e557a67620659b116f79ba7074d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memTemplParams" colspan="2"><a id="aff69ca2e7cb612911bd85ae82bf0c0b8"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aff69ca2e7cb612911bd85ae82bf0c0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59c44515b0155c808f9d77b5d430cac"><td class="memTemplParams" colspan="2"><a id="ab59c44515b0155c808f9d77b5d430cac"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ab59c44515b0155c808f9d77b5d430cac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ab59c44515b0155c808f9d77b5d430cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1165979d19164d7762c6fdf560bf1b15"><td class="memTemplParams" colspan="2"><a id="a1165979d19164d7762c6fdf560bf1b15"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a1165979d19164d7762c6fdf560bf1b15"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1less__or__equal.html">accessor::less_or_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a1165979d19164d7762c6fdf560bf1b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323744fe971b1e322b0adde873ee6fc6"><td class="memTemplParams" colspan="2"><a id="a323744fe971b1e322b0adde873ee6fc6"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a323744fe971b1e322b0adde873ee6fc6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a323744fe971b1e322b0adde873ee6fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aaf424ba6928e394060e3daee3ec841"><td class="memTemplParams" colspan="2"><a id="a9aaf424ba6928e394060e3daee3ec841"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a9aaf424ba6928e394060e3daee3ec841"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a9aaf424ba6928e394060e3daee3ec841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memTemplParams" colspan="2"><a id="a21e68118a9f8c4eb4c5c5d93a9a98e84"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a21e68118a9f8c4eb4c5c5d93a9a98e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e5c84356708a0ee714198c211118d7"><td class="memTemplParams" colspan="2"><a id="a60e5c84356708a0ee714198c211118d7"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a60e5c84356708a0ee714198c211118d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1greater__or__equal.html">accessor::greater_or_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a60e5c84356708a0ee714198c211118d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b12398fc180e82bf31cd7aa210ba731"><td class="memTemplParams" colspan="2"><a id="a9b12398fc180e82bf31cd7aa210ba731"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9b12398fc180e82bf31cd7aa210ba731"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9b12398fc180e82bf31cd7aa210ba731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memTemplParams" colspan="2"><a id="a754f3a148a6ffbd2ebc1de4950f874d3"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a754f3a148a6ffbd2ebc1de4950f874d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae093d67dc43ee09722642623abfef970"><td class="memTemplParams" colspan="2"><a id="ae093d67dc43ee09722642623abfef970"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ae093d67dc43ee09722642623abfef970"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ae093d67dc43ee09722642623abfef970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045f895f0a9784b07f8df78507b278ac"><td class="memTemplParams" colspan="2"><a id="a045f895f0a9784b07f8df78507b278ac"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a045f895f0a9784b07f8df78507b278ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1equal.html">accessor::equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a045f895f0a9784b07f8df78507b278ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3192cdc0e20795c77068697d2fbb87b3"><td class="memTemplParams" colspan="2"><a id="a3192cdc0e20795c77068697d2fbb87b3"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a3192cdc0e20795c77068697d2fbb87b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a3192cdc0e20795c77068697d2fbb87b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaba7c56d10cf4ac78abbf1915abc813"><td class="memTemplParams" colspan="2"><a id="acaba7c56d10cf4ac78abbf1915abc813"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:acaba7c56d10cf4ac78abbf1915abc813"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:acaba7c56d10cf4ac78abbf1915abc813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memTemplParams" colspan="2"><a id="a6f677bbc94cc91eb9edf9c55e6f3bec0"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a6f677bbc94cc91eb9edf9c55e6f3bec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca70088d495ea60993e6bf86d155571c"><td class="memTemplParams" colspan="2"><a id="aca70088d495ea60993e6bf86d155571c"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aca70088d495ea60993e6bf86d155571c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1not__equal.html">accessor::not_equal</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aca70088d495ea60993e6bf86d155571c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memTemplParams" colspan="2"><a id="a5409d98fe2fc4ae364dab8e6a76d4016"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a5409d98fe2fc4ae364dab8e6a76d4016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memTemplParams" colspan="2"><a id="a90d30de07b0c483d6c25cd9ac7f27487"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a90d30de07b0c483d6c25cd9ac7f27487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memTemplParams" colspan="2"><a id="ad2e2f0c77efabd6d47e3dbb4b2a8270b"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ad2e2f0c77efabd6d47e3dbb4b2a8270b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memTemplParams" colspan="2"><a id="aa475e217d2a6cec2e7be2b5b67c1f411"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__or.html">accessor::logical_or</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator||</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa475e217d2a6cec2e7be2b5b67c1f411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49f8d45550558d6d45a427786a84cc"><td class="memTemplParams" colspan="2"><a id="a7e49f8d45550558d6d45a427786a84cc"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a7e49f8d45550558d6d45a427786a84cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a7e49f8d45550558d6d45a427786a84cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memTemplParams" colspan="2"><a id="aa77d1017b99c32afdf5c38af1b29e4d0"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa77d1017b99c32afdf5c38af1b29e4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b0898350bd21a971d8687355b69ecb"><td class="memTemplParams" colspan="2"><a id="ab2b0898350bd21a971d8687355b69ecb"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ab2b0898350bd21a971d8687355b69ecb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ab2b0898350bd21a971d8687355b69ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memTemplParams" colspan="2"><a id="a9c4df98eb3e10aba66c6a5ecff830b68"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1logical__and.html">accessor::logical_and</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;&amp;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a9c4df98eb3e10aba66c6a5ecff830b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83739f5164d2c071abe69bb4fb89203"><td class="memTemplParams" colspan="2"><a id="aa83739f5164d2c071abe69bb4fb89203"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:aa83739f5164d2c071abe69bb4fb89203"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:aa83739f5164d2c071abe69bb4fb89203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memTemplParams" colspan="2"><a id="ab4bc92ac2122a4fc41a92003bfaf9c4c"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:ab4bc92ac2122a4fc41a92003bfaf9c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memTemplParams" colspan="2"><a id="aa8261b7cf1c5356d8acd690cf6da78ae"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:aa8261b7cf1c5356d8acd690cf6da78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5919cbe46045874ae714655dadf21f7"><td class="memTemplParams" colspan="2"><a id="af5919cbe46045874ae714655dadf21f7"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af5919cbe46045874ae714655dadf21f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__or.html">accessor::bitwise_or</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af5919cbe46045874ae714655dadf21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memTemplParams" colspan="2"><a id="a863cedf8acfcbe8fd49bdfd75c5cf98c"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a863cedf8acfcbe8fd49bdfd75c5cf98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810dbc268bd5afe52957e86516a52144"><td class="memTemplParams" colspan="2"><a id="a810dbc268bd5afe52957e86516a52144"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a810dbc268bd5afe52957e86516a52144"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a810dbc268bd5afe52957e86516a52144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c492e305ee2fede581c5064e2a67e9b"><td class="memTemplParams" colspan="2"><a id="a6c492e305ee2fede581c5064e2a67e9b"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a6c492e305ee2fede581c5064e2a67e9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a6c492e305ee2fede581c5064e2a67e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memTemplParams" colspan="2"><a id="a7510cbb7b5d9f64e475ee454eff5936d"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__and.html">accessor::bitwise_and</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&amp;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a7510cbb7b5d9f64e475ee454eff5936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9632339715461aa398490e01ff0061c1"><td class="memTemplParams" colspan="2"><a id="a9632339715461aa398490e01ff0061c1"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9632339715461aa398490e01ff0061c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9632339715461aa398490e01ff0061c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa283184871e7e3c2732eee8d5730a58f"><td class="memTemplParams" colspan="2"><a id="aa283184871e7e3c2732eee8d5730a58f"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aa283184871e7e3c2732eee8d5730a58f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aa283184871e7e3c2732eee8d5730a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memTemplParams" colspan="2"><a id="afa4929c556ad4f2690b9c8aeaf2cea4f"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:afa4929c556ad4f2690b9c8aeaf2cea4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110b727befb8ac474ece75ac62ae6668"><td class="memTemplParams" colspan="2"><a id="a110b727befb8ac474ece75ac62ae6668"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a110b727befb8ac474ece75ac62ae6668"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1bitwise__xor.html">accessor::bitwise_xor</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator^</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a110b727befb8ac474ece75ac62ae6668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0fb3b3ff225d07950e27943d29593f"><td class="memTemplParams" colspan="2"><a id="a3a0fb3b3ff225d07950e27943d29593f"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a3a0fb3b3ff225d07950e27943d29593f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a3a0fb3b3ff225d07950e27943d29593f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7500d198bc217d251346560148657e"><td class="memTemplParams" colspan="2"><a id="a6d7500d198bc217d251346560148657e"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a6d7500d198bc217d251346560148657e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a6d7500d198bc217d251346560148657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34302fcd90695bfd2e0267da0454c8b9"><td class="memTemplParams" colspan="2"><a id="a34302fcd90695bfd2e0267da0454c8b9"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a34302fcd90695bfd2e0267da0454c8b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a34302fcd90695bfd2e0267da0454c8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaf5e40ac6cca7985630beed38975e0"><td class="memTemplParams" colspan="2"><a id="aeeaf5e40ac6cca7985630beed38975e0"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aeeaf5e40ac6cca7985630beed38975e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1left__shift.html">accessor::left_shift</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aeeaf5e40ac6cca7985630beed38975e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memTemplParams" colspan="2"><a id="a787e41cf20d8dbf332b38f9e6bd014c8"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a787e41cf20d8dbf332b38f9e6bd014c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44870f0181208f0e356c0510ef136f0a"><td class="memTemplParams" colspan="2"><a id="a44870f0181208f0e356c0510ef136f0a"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a44870f0181208f0e356c0510ef136f0a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a44870f0181208f0e356c0510ef136f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memTemplParams" colspan="2"><a id="a0467ed5f04ab215c0c5639f0a4f880b5"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a0467ed5f04ab215c0c5639f0a4f880b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memTemplParams" colspan="2"><a id="a7fb6c9447f2f6620551a3c6900f290fd"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1right__shift.html">accessor::right_shift</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;&gt;</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a7fb6c9447f2f6620551a3c6900f290fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9525dbd3cab0f88c517605970eeec941"><td class="memTemplParams" colspan="2"><a id="a9525dbd3cab0f88c517605970eeec941"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a9525dbd3cab0f88c517605970eeec941"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a9525dbd3cab0f88c517605970eeec941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6953ed43df70b724348be1ee86e086c0"><td class="memTemplParams" colspan="2"><a id="a6953ed43df70b724348be1ee86e086c0"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a6953ed43df70b724348be1ee86e086c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a6953ed43df70b724348be1ee86e086c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12db47e6880294113f8cfc3b260b5c44"><td class="memTemplParams" colspan="2"><a id="a12db47e6880294113f8cfc3b260b5c44"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a12db47e6880294113f8cfc3b260b5c44"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a12db47e6880294113f8cfc3b260b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1cf347b60113f5504144cf885be230"><td class="memTemplParams" colspan="2"><a id="a4e1cf347b60113f5504144cf885be230"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a4e1cf347b60113f5504144cf885be230"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1max__operaton.html">accessor::max_operaton</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a4e1cf347b60113f5504144cf885be230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memTemplParams" colspan="2"><a id="a92f6a1d8d6ddb53fa5604c4fffab2215"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:a92f6a1d8d6ddb53fa5604c4fffab2215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed7f057eac94682a4aa2735af799e56a"><td class="memTemplParams" colspan="2"><a id="aed7f057eac94682a4aa2735af799e56a"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:aed7f057eac94682a4aa2735af799e56a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:aed7f057eac94682a4aa2735af799e56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memTemplParams" colspan="2"><a id="ac71f6df883e89643ce21f8adbb2ce07e"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:ac71f6df883e89643ce21f8adbb2ce07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612eba2f92e21c5809701a80864565d"><td class="memTemplParams" colspan="2"><a id="af612eba2f92e21c5809701a80864565d"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:af612eba2f92e21c5809701a80864565d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1min__operaton.html">accessor::min_operaton</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:af612eba2f92e21c5809701a80864565d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25a3968d03816b31d07e8f45499796d"><td class="memTemplParams" colspan="2"><a id="af25a3968d03816b31d07e8f45499796d"></a>
template&lt;typename Accessor &gt; </td></tr>
<tr class="memitem:af25a3968d03816b31d07e8f45499796d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_range, Accessor, Accessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; Accessor &gt; &amp;second)</td></tr>
<tr class="separator:af25a3968d03816b31d07e8f45499796d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821da786ceea22fbd7b3c259feef2ac2"><td class="memTemplParams" colspan="2"><a id="a821da786ceea22fbd7b3c259feef2ac2"></a>
template&lt;typename FirstAccessor , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a821da786ceea22fbd7b3c259feef2ac2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_range, FirstAccessor, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a821da786ceea22fbd7b3c259feef2ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memTemplParams" colspan="2"><a id="a0eb6555448ea2dc4bcd3004eb7fa6479"></a>
template&lt;typename FirstAccessor , typename SecondOperand &gt; </td></tr>
<tr class="memitem:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::range_by_scalar, FirstAccessor, SecondOperand &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const <a class="el" href="classgko_1_1range.html">range</a>&lt; FirstAccessor &gt; &amp;first, const SecondOperand &amp;second)</td></tr>
<tr class="separator:a0eb6555448ea2dc4bcd3004eb7fa6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memTemplParams" colspan="2"><a id="a2193d82004fe19f7fa1d9441e7e179c1"></a>
template&lt;typename FirstOperand , typename SecondAccessor &gt; </td></tr>
<tr class="memitem:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgko_1_1range.html">range</a>&lt; <a class="el" href="structgko_1_1accessor_1_1mmul__operation.html">accessor::mmul_operation</a>&lt; ::gko::detail::operation_kind::scalar_by_range, FirstOperand, SecondAccessor &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mmul</b> (const FirstOperand &amp;first, const <a class="el" href="classgko_1_1range.html">range</a>&lt; SecondAccessor &gt; &amp;second)</td></tr>
<tr class="separator:a2193d82004fe19f7fa1d9441e7e179c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4dbafa6e062c2036991ec8c3f6b201cf">operator==</a> (<a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> x, <a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> y) noexcept</td></tr>
<tr class="memdesc:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are equal.  <a href="namespacegko.html#a4dbafa6e062c2036991ec8c3f6b201cf">More...</a><br /></td></tr>
<tr class="separator:a4dbafa6e062c2036991ec8c3f6b201cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d408b4cd77aae6cac7a40c8307fddb"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#a61d408b4cd77aae6cac7a40c8307fddb">operator!=</a> (<a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> x, <a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a> y) noexcept</td></tr>
<tr class="memdesc:a61d408b4cd77aae6cac7a40c8307fddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are different.  <a href="namespacegko.html#a61d408b4cd77aae6cac7a40c8307fddb">More...</a><br /></td></tr>
<tr class="separator:a61d408b4cd77aae6cac7a40c8307fddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beb80750459e4201aa9d882d2d074c3"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a1beb80750459e4201aa9d882d2d074c3"><td class="memTemplItemLeft" align="right" valign="top">detail::cloned_type&lt; Pointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">clone</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:a1beb80750459e4201aa9d882d2d074c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique clone of the object pointed to by <code>p</code>.  <a href="namespacegko.html#a1beb80750459e4201aa9d882d2d074c3">More...</a><br /></td></tr>
<tr class="separator:a1beb80750459e4201aa9d882d2d074c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b00a9dd24aa08d4495762d89f3762a"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a13b00a9dd24aa08d4495762d89f3762a"><td class="memTemplItemLeft" align="right" valign="top">detail::cloned_type&lt; Pointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a13b00a9dd24aa08d4495762d89f3762a">clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, const Pointer &amp;p)</td></tr>
<tr class="memdesc:a13b00a9dd24aa08d4495762d89f3762a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unique clone of the object pointed to by <code>p</code> on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> <code>exec</code>.  <a href="namespacegko.html#a13b00a9dd24aa08d4495762d89f3762a">More...</a><br /></td></tr>
<tr class="separator:a13b00a9dd24aa08d4495762d89f3762a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memTemplParams" colspan="2">template&lt;typename OwningPointer &gt; </td></tr>
<tr class="memitem:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memTemplItemLeft" align="right" valign="top">detail::shared_type&lt; OwningPointer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">share</a> (OwningPointer &amp;&amp;p)</td></tr>
<tr class="memdesc:a3ce296f73db0ff398bdea6009a3a5c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the object pointed to by <code>p</code> as shared.  <a href="namespacegko.html#a3ce296f73db0ff398bdea6009a3a5c58">More...</a><br /></td></tr>
<tr class="separator:a3ce296f73db0ff398bdea6009a3a5c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memTemplParams" colspan="2">template&lt;typename OwningPointer &gt; </td></tr>
<tr class="memitem:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference&lt; OwningPointer &gt;::type &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">give</a> (OwningPointer &amp;&amp;p)</td></tr>
<tr class="memdesc:acbd3fd6d07e498892881e8e2ab0b4167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks that the object pointed to by <code>p</code> can be given to the callee.  <a href="namespacegko.html#acbd3fd6d07e498892881e8e2ab0b4167">More...</a><br /></td></tr>
<tr class="separator:acbd3fd6d07e498892881e8e2ab0b4167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edc2273b5627ec552ea423b60493be3"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a4edc2273b5627ec552ea423b60493be3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; detail::have_ownership_s&lt; Pointer &gt;::value, detail::pointee&lt; Pointer &gt; * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a4edc2273b5627ec552ea423b60493be3">lend</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:a4edc2273b5627ec552ea423b60493be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>.  <a href="namespacegko.html#a4edc2273b5627ec552ea423b60493be3">More...</a><br /></td></tr>
<tr class="separator:a4edc2273b5627ec552ea423b60493be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d45734020b4487bdffc1f6a12d98672"><td class="memTemplParams" colspan="2">template&lt;typename Pointer &gt; </td></tr>
<tr class="memitem:a9d45734020b4487bdffc1f6a12d98672"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!detail::have_ownership_s&lt; Pointer &gt;::value, detail::pointee&lt; Pointer &gt; * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a9d45734020b4487bdffc1f6a12d98672">lend</a> (const Pointer &amp;p)</td></tr>
<tr class="memdesc:a9d45734020b4487bdffc1f6a12d98672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>.  <a href="namespacegko.html#a9d45734020b4487bdffc1f6a12d98672">More...</a><br /></td></tr>
<tr class="separator:a9d45734020b4487bdffc1f6a12d98672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ce7e87aec389b5210630bb617b4baa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a73ce7e87aec389b5210630bb617b4baa"><td class="memTemplItemLeft" align="right" valign="top">std::decay&lt; T &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">as</a> (U *obj)</td></tr>
<tr class="memdesc:a73ce7e87aec389b5210630bb617b4baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion.  <a href="namespacegko.html#a73ce7e87aec389b5210630bb617b4baa">More...</a><br /></td></tr>
<tr class="separator:a73ce7e87aec389b5210630bb617b4baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289e84ef5dea2f579dd12f27140a1470"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a289e84ef5dea2f579dd12f27140a1470"><td class="memTemplItemLeft" align="right" valign="top">const std::decay&lt; T &gt;::type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#a289e84ef5dea2f579dd12f27140a1470">as</a> (const U *obj)</td></tr>
<tr class="memdesc:a289e84ef5dea2f579dd12f27140a1470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs polymorphic type conversion.  <a href="namespacegko.html#a289e84ef5dea2f579dd12f27140a1470">More...</a><br /></td></tr>
<tr class="separator:a289e84ef5dea2f579dd12f27140a1470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c0782fb35cc18cb404716d9b6f2c0e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9c0782fb35cc18cb404716d9b6f2c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgko_1_1temporary__clone.html">temporary_clone</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacegko.html#aa9c0782fb35cc18cb404716d9b6f2c0e">make_temporary_clone</a> (std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, T *ptr)</td></tr>
<tr class="memdesc:aa9c0782fb35cc18cb404716d9b6f2c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classgko_1_1temporary__clone.html" title="A temporary_clone is a special smart pointer-like object that is designed to hold an object temporari...">temporary_clone</a>.  <a href="namespacegko.html#aa9c0782fb35cc18cb404716d9b6f2c0e">More...</a><br /></td></tr>
<tr class="separator:aa9c0782fb35cc18cb404716d9b6f2c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e5d651d3fc23e6ed48980efd2098d3"><td class="memItemLeft" align="right" valign="top"><a id="a70e5d651d3fc23e6ed48980efd2098d3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:a70e5d651d3fc23e6ed48980efd2098d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a749f76b73c3b0e161e2019ad12308"><td class="memItemLeft" align="right" valign="top"><a id="aa3a749f76b73c3b0e161e2019ad12308"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aa3a749f76b73c3b0e161e2019ad12308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaafa7179e5dbc1f1c02197598664fb"><td class="memItemLeft" align="right" valign="top"><a id="aeeaafa7179e5dbc1f1c02197598664fb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aeeaafa7179e5dbc1f1c02197598664fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d150bb18c9fbdc62c2a02315bd908b"><td class="memItemLeft" align="right" valign="top"><a id="af2d150bb18c9fbdc62c2a02315bd908b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:af2d150bb18c9fbdc62c2a02315bd908b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac033cb13ef2c4d291a894f26d2c64862"><td class="memItemLeft" align="right" valign="top"><a id="ac033cb13ef2c4d291a894f26d2c64862"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:ac033cb13ef2c4d291a894f26d2c64862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6724904a78b5293c610d113e3b23682"><td class="memItemLeft" align="right" valign="top"><a id="aa6724904a78b5293c610d113e3b23682"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structgko_1_1version.html">version</a> &amp;first, const <a class="el" href="structgko_1_1version.html">version</a> &amp;second)</td></tr>
<tr class="separator:aa6724904a78b5293c610d113e3b23682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ef652f487afe43aebcf778038ff780"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ae0ef652f487afe43aebcf778038ff780">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structgko_1_1version.html">version</a> &amp;ver)</td></tr>
<tr class="memdesc:ae0ef652f487afe43aebcf778038ff780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints version information to a stream.  <a href="namespacegko.html#ae0ef652f487afe43aebcf778038ff780">More...</a><br /></td></tr>
<tr class="separator:ae0ef652f487afe43aebcf778038ff780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#ad9e3ba96a10fe47a03ceef39b45bd43c">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classgko_1_1version__info.html">version_info</a> &amp;ver_info)</td></tr>
<tr class="memdesc:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints library version information in human-readable format to a stream.  <a href="namespacegko.html#ad9e3ba96a10fe47a03ceef39b45bd43c">More...</a><br /></td></tr>
<tr class="separator:ad9e3ba96a10fe47a03ceef39b45bd43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__formats.html#ga2f54bac1e95fb3ef03974fa9c9088491">initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__mat__formats.html#ga2f54bac1e95fb3ef03974fa9c9088491">More...</a><br /></td></tr>
<tr class="separator:ga2f54bac1e95fb3ef03974fa9c9088491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__formats.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">initialize</a> (std::initializer_list&lt; typename Matrix::value_type &gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a column-vector.  <a href="group__mat__formats.html#gaac5f7b4ff3b43dbc6918c687dd7d2d2e">More...</a><br /></td></tr>
<tr class="separator:gaac5f7b4ff3b43dbc6918c687dd7d2d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__formats.html#gaaf2520e5921e1bea00853c290f4fc28f">initialize</a> (<a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a> stride, std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gaaf2520e5921e1bea00853c290f4fc28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__mat__formats.html#gaaf2520e5921e1bea00853c290f4fc28f">More...</a><br /></td></tr>
<tr class="separator:gaaf2520e5921e1bea00853c290f4fc28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplParams" colspan="2">template&lt;typename Matrix , typename... TArgs&gt; </td></tr>
<tr class="memitem:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Matrix &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mat__formats.html#gabe4ff67be5b3aae4e981b33ea9883385">initialize</a> (std::initializer_list&lt; std::initializer_list&lt; typename Matrix::value_type &gt;&gt; vals, std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt; exec, TArgs &amp;&amp;... create_args)</td></tr>
<tr class="memdesc:gabe4ff67be5b3aae4e981b33ea9883385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and initializes a matrix.  <a href="group__mat__formats.html#gabe4ff67be5b3aae4e981b33ea9883385">More...</a><br /></td></tr>
<tr class="separator:gabe4ff67be5b3aae4e981b33ea9883385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf34f605deac3e475189bb5b8a0fa71a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#acf34f605deac3e475189bb5b8a0fa71a">operator==</a> (const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;x, const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;y) noexcept</td></tr>
<tr class="memdesc:acf34f605deac3e475189bb5b8a0fa71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two stopping statuses are equivalent.  <a href="namespacegko.html#acf34f605deac3e475189bb5b8a0fa71a">More...</a><br /></td></tr>
<tr class="separator:acf34f605deac3e475189bb5b8a0fa71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf1dbf5054c76e154490d825b0f44ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#accf1dbf5054c76e154490d825b0f44ee">operator!=</a> (const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;x, const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;y) noexcept</td></tr>
<tr class="memdesc:accf1dbf5054c76e154490d825b0f44ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two stopping statuses are different.  <a href="namespacegko.html#accf1dbf5054c76e154490d825b0f44ee">More...</a><br /></td></tr>
<tr class="separator:accf1dbf5054c76e154490d825b0f44ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acae2e648052ec788bd8ba9e0192652a6"><td class="memItemLeft" align="right" valign="top"><a id="acae2e648052ec788bd8ba9e0192652a6"></a>
constexpr <a class="el" href="namespacegko.html#a6e5c95df0ae4e47aab2f604a22d98ee7">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegko.html#acae2e648052ec788bd8ba9e0192652a6">byte_size</a> = CHAR_BIT</td></tr>
<tr class="memdesc:acae2e648052ec788bd8ba9e0192652a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits in a byte. <br /></td></tr>
<tr class="separator:acae2e648052ec788bd8ba9e0192652a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Ginkgo namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aeede19206954d5c8ebd04c95cf63bb88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeede19206954d5c8ebd04c95cf63bb88">&#9670;&nbsp;</a></span>is_complex_s</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">gko::is_complex_s</a> = typedef detail::is_complex_impl&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to check if T is a complex value during compile time by accessing the <code>value</code> attribute of this struct. </p>
<p>If <code>value</code> is <code>true</code>, T is a complex type, if it is <code>false</code>, T is not a complex type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae749a5ea11a93c1bcc9158d9a6e9fb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae749a5ea11a93c1bcc9158d9a6e9fb68">&#9670;&nbsp;</a></span>layout_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">gko::layout_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the layout type when writing data in matrix market format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5"></a>array&#160;</td><td class="fielddoc"><p>The matrix should be written as dense matrix in column-major order. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae749a5ea11a93c1bcc9158d9a6e9fb68af5d7aa3ba4929cc12dc51a92c59fabd3"></a>coordinate&#160;</td><td class="fielddoc"><p>The matrix should be written as a sparse matrix in coordinate format. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a57797fc0a00fd4b7ff34ca4bfc84bc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57797fc0a00fd4b7ff34ca4bfc84bc51">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::abs </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &gt;= <a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5" title="Returns the additive identity for T.">zero&lt;T&gt;()</a> ? x : -x; </dd></dl>

</div>
</div>
<a id="a289e84ef5dea2f579dd12f27140a1470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289e84ef5dea2f579dd12f27140a1470">&#9670;&nbsp;</a></span>as() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::decay&lt;T&gt;::type* gko::as </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion. </p>
<p>This is the constant version of the function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object which should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a pointer to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. </dd></dl>

</div>
</div>
<a id="a73ce7e87aec389b5210630bb617b4baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ce7e87aec389b5210630bb617b4baa">&#9670;&nbsp;</a></span>as() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::decay&lt;T&gt;::type* gko::as </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs polymorphic type conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>requested result type </td></tr>
    <tr><td class="paramname">U</td><td>static type of the passed object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>the object which should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful, returns a pointer to the subtype, otherwise throws <a class="el" href="classgko_1_1NotSupported.html" title="NotSupported is thrown in case it is not possible to perform the requested operation on the given obj...">NotSupported</a>. </dd></dl>

</div>
</div>
<a id="a93065a86872e6511b701b73b75823483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93065a86872e6511b701b73b75823483">&#9670;&nbsp;</a></span>ceildiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a> gko::ceildiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a6c57dbf3168b1ecad3ea133aaf2efbc1">int64</a>&#160;</td>
          <td class="paramname"><em>den</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs integer division with rounding up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>numerator </td></tr>
    <tr><td class="paramname">den</td><td>denominator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the ceiled quotient. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structgko_1_1preconditioner_1_1block__interleaved__storage__scheme.html#ae46b38432c1e1b87d5743a649f2cfe84">gko::preconditioner::block_interleaved_storage_scheme&lt; index_type &gt;::compute_storage_space()</a>.</p>

</div>
</div>
<a id="a1beb80750459e4201aa9d882d2d074c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1beb80750459e4201aa9d882d2d074c3">&#9670;&nbsp;</a></span>clone() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::cloned_type&lt;Pointer&gt; gko::clone </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unique clone of the object pointed to by <code>p</code>. </p>
<p>The pointee (i.e. <code>*p</code>) needs to have a clone method that returns a std::unique_ptr in order for this method to work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The difference between this function and directly calling LinOp::clone() is that this one preserves the static type of the object. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1temporary__clone.html#a73b2e7db31555df95b827625f85da4be">gko::temporary_clone&lt; T &gt;::temporary_clone()</a>.</p>

</div>
</div>
<a id="a13b00a9dd24aa08d4495762d89f3762a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b00a9dd24aa08d4495762d89f3762a">&#9670;&nbsp;</a></span>clone() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::cloned_type&lt;Pointer&gt; gko::clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a unique clone of the object pointed to by <code>p</code> on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> <code>exec</code>. </p>
<p>The pointee (i.e. <code>*p</code>) needs to have a clone method that takes an executor and returns a std::unique_ptr in order for this method to work.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the cloned object should be stored </td></tr>
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The difference between this function and directly calling LinOp::clone() is that this one preserves the static type of the object. </dd></dl>

</div>
</div>
<a id="acdaec5c4f959a948a6d0f3e99a57c7ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaec5c4f959a948a6d0f3e99a57c7ea">&#9670;&nbsp;</a></span>conj()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T gko::conj </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the conjugate of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the number to conjugate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>conjugate of the object (by default, the object itself) </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm()</a>.</p>

</div>
</div>
<a id="add859060efaa729c84788bb4f6582e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add859060efaa729c84788bb4f6582e9f">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const R, std::function&lt;void(const R *)&gt; &gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unique pointer (with dynamically bound deleter) to the converted object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a version of the function which adds the const qualifier to the result if the input had the same qualifier. </dd></dl>

</div>
</div>
<a id="a0f28847393e540a33fdda8cd80584789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f28847393e540a33fdda8cd80584789">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const R&gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const T &gt;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p></p>
<p>This is the version that takes in the std::shared_ptr and returns a std::shared_ptr</p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the converted object</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is a version of the function which adds the const qualifier to the result if the input had the same qualifier. </dd></dl>

</div>
</div>
<a id="ac2b925f8d9f288210c7d1f0e00e5c495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b925f8d9f288210c7d1f0e00e5c495">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;R&gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; T &gt;&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>This is the version that takes in the std::shared_ptr and returns a std::shared_ptr</p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to the converted object </dd></dl>

</div>
</div>
<a id="ac5cef6e5e9e02b8d77ce01be41117cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cef6e5e9e02b8d77ce01be41117cc0">&#9670;&nbsp;</a></span>copy_and_convert_to() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;R, std::function&lt;void(R *)&gt; &gt; gko::copy_and_convert_to </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the object to R and places it on <a class="el" href="classgko_1_1Executor.html" title="The first step in using the Ginkgo library consists of creating an executor.">Executor</a> exec. </p>
<p>If the object is already of the requested type and on the requested executor, the copy and conversion is avoided and a reference to the original object is returned instead.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>the type to which the object should be converted </td></tr>
    <tr><td class="paramname">T</td><td>the type of the input object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the result should be placed </td></tr>
    <tr><td class="paramname">obj</td><td>the object that should be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a unique pointer (with dynamically bound deleter) to the converted object </dd></dl>

</div>
</div>
<a id="a4eea40e4123a3fdb60fcd92f902c6d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eea40e4123a3fdb60fcd92f902c6d6d">&#9670;&nbsp;</a></span>get_significant_bit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a> gko::get_significant_bit </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#a318c831e3fe269ba04c6ed8bf5a71073">uint32</a>&#160;</td>
          <td class="paramname"><em>hint</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the most significant bit of the number. </p>
<p>This is the same as the rounded down base-2 logarithm of the number.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric type supporting bit shift and comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>a number </td></tr>
    <tr><td class="paramname">hint</td><td>a lower bound for the position o the significant bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum of <code>hint</code> and the significant bit position of <code>n</code> </dd></dl>

</div>
</div>
<a id="ad39645fe8148a8a812a9528865a77600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39645fe8148a8a812a9528865a77600">&#9670;&nbsp;</a></span>get_superior_power()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::get_superior_power </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>hint</em> = <code>T{1}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smallest power of <code>base</code> not smaller than <code>limit</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>a numeric type supporting multiplication and comparison</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>the base of the power to be returned </td></tr>
    <tr><td class="paramname">limit</td><td>the lower limit on the size of the power returned </td></tr>
    <tr><td class="paramname">hint</td><td>a lower bound on the result, has to be a power of base</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest power of <code>base</code> not smaller than <code>limit</code> </dd></dl>

</div>
</div>
<a id="acbd3fd6d07e498892881e8e2ab0b4167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd3fd6d07e498892881e8e2ab0b4167">&#9670;&nbsp;</a></span>give()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwningPointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;OwningPointer&gt;::type&amp;&amp; gko::give </td>
          <td>(</td>
          <td class="paramtype">OwningPointer &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks that the object pointed to by <code>p</code> can be given to the callee. </p>
<p>Effectively calls <code>std::move(p)</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OwningPointer</td><td>type of pointer with ownership to the object (has to be a smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The original pointer <code>p</code> becomes invalid after this call. </dd></dl>

</div>
</div>
<a id="a7ff1061513b10ccd5122015d2e5f9faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff1061513b10ccd5122015d2e5f9faa">&#9670;&nbsp;</a></span>imag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::imag </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the imaginary part of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>imaginary part of the object (by default, <a class="el" href="namespacegko.html#a70dbe01ff95c7b953d3d737424c6feb5" title="Returns the additive identity for T.">zero&lt;T&gt;()</a>) </dd></dl>

</div>
</div>
<a id="a9b3e79911bb6145d7ba865dbe436b915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b3e79911bb6145d7ba865dbe436b915">&#9670;&nbsp;</a></span>is_complex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::is_complex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if T is a complex type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if T is a complex type, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a id="afb0f20b5d373f9439702e723d48548fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0f20b5d373f9439702e723d48548fa">&#9670;&nbsp;</a></span>isfinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xstd::enable_if_t&lt;<a class="el" href="namespacegko.html#aeede19206954d5c8ebd04c95cf63bb88">is_complex_s</a>&lt;T&gt;::value, bool&gt; gko::isfinite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all components of a complex value are finite, meaning they are neither +/- infinity nor NaN. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>complex type of the value to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>complex value to check</td></tr>
  </table>
  </dd>
</dl>
<p>returns <code>true</code> if both components of the given value are finite, meaning they are neither +/- infinity nor NaN. </p>

</div>
</div>
<a id="a4edc2273b5627ec552ea423b60493be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edc2273b5627ec552ea423b60493be3">&#9670;&nbsp;</a></span>lend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;detail::have_ownership_s&lt;Pointer&gt;::value, detail::pointee&lt;Pointer&gt; *&gt;::type gko::lend </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the overload for owning (smart) pointers, that behaves the same as calling .get() on the smart pointer. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1log_1_1EnableLogging.html#aba5317f8a03956a61d770e9b07fc65cc">gko::log::EnableLogging&lt; Executor &gt;::remove_logger()</a>.</p>

</div>
</div>
<a id="a9d45734020b4487bdffc1f6a12d98672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d45734020b4487bdffc1f6a12d98672">&#9670;&nbsp;</a></span>lend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!detail::have_ownership_s&lt;Pointer&gt;::value, detail::pointee&lt;Pointer&gt; *&gt;::type gko::lend </td>
          <td>(</td>
          <td class="paramtype">const Pointer &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a non-owning (plain) pointer to the object pointed to by <code>p</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Pointer</td><td>type of pointer to the object (plain or smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is the overload for non-owning (plain) pointers, that just returns <code>p</code>. </dd></dl>

</div>
</div>
<a id="aa9c0782fb35cc18cb404716d9b6f2c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c0782fb35cc18cb404716d9b6f2c0e">&#9670;&nbsp;</a></span>make_temporary_clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgko_1_1temporary__clone.html">temporary_clone</a>&lt;T&gt; gko::make_temporary_clone </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classgko_1_1Executor.html">Executor</a> &gt;&#160;</td>
          <td class="paramname"><em>exec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classgko_1_1temporary__clone.html" title="A temporary_clone is a special smart pointer-like object that is designed to hold an object temporari...">temporary_clone</a>. </p>
<p>This is a helper function which avoids the need to explicitly specify the type of the object, as would be the case if using the constructor of <a class="el" href="classgko_1_1temporary__clone.html" title="A temporary_clone is a special smart pointer-like object that is designed to hold an object temporari...">temporary_clone</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">exec</td><td>the executor where the clone will be created </td></tr>
    <tr><td class="paramname">ptr</td><td>a pointer to the object of which the clone will be created </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classgko_1_1matrix_1_1Dense.html#ae6c4c15972b76bf7d8f6d50a96abda8d">gko::matrix::Dense&lt; ValueType &gt;::add_scaled()</a>, <a class="el" href="classgko_1_1LinOp.html#a0449b2fc705d2f970855af23b5e2788e">gko::LinOp::apply()</a>, <a class="el" href="classgko_1_1matrix_1_1Coo.html#ad2e97eee0ad21f8896f4a82cc5ac8a50">gko::matrix::Coo&lt; ValueType, IndexType &gt;::apply2()</a>, <a class="el" href="classgko_1_1matrix_1_1Dense.html#acb568ff44addb095b82bbd2fbe704761">gko::matrix::Dense&lt; ValueType &gt;::compute_dot()</a>, <a class="el" href="classgko_1_1matrix_1_1Dense.html#a97fd354c4a26814586cd256b5f0d7bea">gko::matrix::Dense&lt; ValueType &gt;::compute_norm2()</a>, and <a class="el" href="classgko_1_1matrix_1_1Dense.html#a35cb8dfff52daf3aa8995597d26981ec">gko::matrix::Dense&lt; ValueType &gt;::scale()</a>.</p>

</div>
</div>
<a id="af1812df45c6ec07780d579a12b64c753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1812df45c6ec07780d579a12b64c753">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the larger of the arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &gt;= y ? x : y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++11 version of this function is not constexpr, thus we provide our own implementation. </dd></dl>

</div>
</div>
<a id="aaaf8487194bcb40b528969c187a413a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf8487194bcb40b528969c187a413a0">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the smaller of the arguments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the arguments</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramname">y</td><td>second argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x &lt;= y ? x : y</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++11 version of this function is not <code>constexpr</code>, thus we provide our own implementation. </dd></dl>

</div>
</div>
<a id="a0059e27f8f4bc348ff65c1e60caf47c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0059e27f8f4bc348ff65c1e60caf47c8">&#9670;&nbsp;</a></span>one() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::one </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the multiplicative identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative identity for T </dd></dl>

</div>
</div>
<a id="ab4f16ecf0a759f46259cf9518f1e4568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4f16ecf0a759f46259cf9518f1e4568">&#9670;&nbsp;</a></span>one() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::one </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the multiplicative identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>the multiplicative identity for T</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version takes an unused reference argument to avoid complicated calls like <code>one&lt;decltype(x)&gt;()</code>. Instead, it allows <code>one(x)</code>. </dd></dl>

</div>
</div>
<a id="a74c3716da36cbedc000aa24006b0bd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c3716da36cbedc000aa24006b0bd46">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_type Dimensionality, typename DimensionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; Dimensionality, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two dim objects are different. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Dimensionality</td><td>number of dimensions of the dim objects </td></tr>
    <tr><td class="paramname">DimensionType</td><td>datatype used to represent each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first object </td></tr>
    <tr><td class="paramname">y</td><td>second object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>!(x == y)</code> </dd></dl>

</div>
</div>
<a id="accf1dbf5054c76e154490d825b0f44ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf1dbf5054c76e154490d825b0f44ee">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two stopping statuses are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a stopping status </td></tr>
    <tr><td class="paramname">y</td><td>a stopping status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>!(x == y)</code> </dd></dl>

</div>
</div>
<a id="a61d408b4cd77aae6cac7a40c8307fddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d408b4cd77aae6cac7a40c8307fddb">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an encoding </td></tr>
    <tr><td class="paramname">y</td><td>an encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>x</code> and <code>y</code> are different encodings. </dd></dl>

</div>
</div>
<a id="ae0ef652f487afe43aebcf778038ff780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ef652f487afe43aebcf778038ff780">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; gko::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1version.html">version</a> &amp;&#160;</td>
          <td class="paramname"><em>ver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints version information to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">ver</td><td>version structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

<p class="reference">References <a class="el" href="structgko_1_1version.html#a019ce1d31714612e0c77c8ef5eb4cfde">gko::version::major</a>, <a class="el" href="structgko_1_1version.html#abb548e6dca39e0a3718ecf13cafbba36">gko::version::minor</a>, <a class="el" href="structgko_1_1version.html#a7580f68f7cf0600bc620c47ed6330c95">gko::version::patch</a>, and <a class="el" href="structgko_1_1version.html#a1bd0eaa4d551c145ff9cd0c10e555ac3">gko::version::tag</a>.</p>

</div>
</div>
<a id="ad9e3ba96a10fe47a03ceef39b45bd43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e3ba96a10fe47a03ceef39b45bd43c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; gko::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1version__info.html">version_info</a> &amp;&#160;</td>
          <td class="paramname"><em>ver_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints library version information in human-readable format to a stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramname">ver_info</td><td>version information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>os </dd></dl>

</div>
</div>
<a id="acf34f605deac3e475189bb5b8a0fa71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf34f605deac3e475189bb5b8a0fa71a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gko::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgko_1_1stopping__status.html">stopping_status</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two stopping statuses are equivalent. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>a stopping status </td></tr>
    <tr><td class="paramname">y</td><td>a stopping status</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if both <code>x</code> and <code>y</code> have the same mask and converged and finalized state </dd></dl>

</div>
</div>
<a id="a4dbafa6e062c2036991ec8c3f6b201cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dbafa6e062c2036991ec8c3f6b201cf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool gko::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgko_1_1precision__reduction.html">precision_reduction</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two <a class="el" href="classgko_1_1precision__reduction.html" title="This class is used to encode storage precisions of low precision algorithms.">precision_reduction</a> encodings are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an encoding </td></tr>
    <tr><td class="paramname">y</td><td>an encoding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if and only if <code>x</code> and <code>y</code> are the same encodings </dd></dl>

</div>
</div>
<a id="a92cf0178c1c55419d32d2bb527e57e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92cf0178c1c55419d32d2bb527e57e5b">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType , typename... MatrixArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;MatrixType&gt; gko::read </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a matrix stored in matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1ReadableFromMatrixData.html" title="A LinOp implementing this interface can read its data from a matrix_data structure.">ReadableFromMatrixData</a> <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type used to store the matrix once it's been read from disk. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to </td></tr>
    <tr><td class="paramname">MatrixArgs</td><td>additional argument types passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data </td></tr>
    <tr><td class="paramname">args</td><td>additional arguments passed to MatrixType constructor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A MatrixType <a class="el" href="classgko_1_1LinOp.html">LinOp</a> filled with data from filename </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#a0b476e0e3df616b08efe85000bff8da0">read_raw()</a>.</p>

</div>
</div>
<a id="a0b476e0e3df616b08efe85000bff8da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b476e0e3df616b08efe85000bff8da0">&#9670;&nbsp;</a></span>read_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType  = default_precision, typename IndexType  = int32&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt;ValueType, IndexType&gt; gko::read_raw </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a matrix stored in matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>input stream from which to read the data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure containing the matrix. The nonzero elements are sorted in lexicographic order of their (row, colum) indexes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that will return the raw matrix data structure. Consider using <a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b" title="Reads a matrix stored in matrix market format from an input stream.">gko::read</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a92cf0178c1c55419d32d2bb527e57e5b">read()</a>.</p>

</div>
</div>
<a id="ae23cfd886cee6e88d77bcbbbe1928b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae23cfd886cee6e88d77bcbbbe1928b78">&#9670;&nbsp;</a></span>real()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::real </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the real part of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>real part of the object (by default, the object itself) </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#abbb55709b10d707b2cbef803832aa834">squared_norm()</a>.</p>

</div>
</div>
<a id="a5f9c197f1db98fdc874f8907978ad114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c197f1db98fdc874f8907978ad114">&#9670;&nbsp;</a></span>round_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#ab5d71c1f4bd1b654df1e561ea7a811f2">reduce_precision</a>&lt;T&gt; gko::round_down </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduces the precision of the input parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the original precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to round down</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rounded down value </dd></dl>

</div>
</div>
<a id="ad45d1c855f31d2f8c1d3d799f2cf21c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45d1c855f31d2f8c1d3d799f2cf21c6">&#9670;&nbsp;</a></span>round_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacegko.html#a373c2b4782d95e675d7e91a75bab101d">increase_precision</a>&lt;T&gt; gko::round_up </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increases the precision of the input parameter. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the original precision</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>the value to round up</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rounded up value </dd></dl>

</div>
</div>
<a id="a3ce296f73db0ff398bdea6009a3a5c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce296f73db0ff398bdea6009a3a5c58">&#9670;&nbsp;</a></span>share()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OwningPointer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">detail::shared_type&lt;OwningPointer&gt; gko::share </td>
          <td>(</td>
          <td class="paramtype">OwningPointer &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the object pointed to by <code>p</code> as shared. </p>
<p>Effectively converts a pointer with ownership to std::shared_ptr.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OwningPointer</td><td>type of pointer with ownership to the object (has to be a smart pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>a pointer to the object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The original pointer <code>p</code> becomes invalid after this call. </dd></dl>

</div>
</div>
<a id="abbb55709b10d707b2cbef803832aa834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbb55709b10d707b2cbef803832aa834">&#9670;&nbsp;</a></span>squared_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto gko::squared_norm </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> -&gt; decltype(<a class="el" href="namespacegko.html#ae23cfd886cee6e88d77bcbbbe1928b78">real</a>(<a class="el" href="namespacegko.html#acdaec5c4f959a948a6d0f3e99a57c7ea">conj</a>(x) * x))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the squared norm of the object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of the object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The squared norm of the object. </dd></dl>

<p class="reference">References <a class="el" href="namespacegko.html#acdaec5c4f959a948a6d0f3e99a57c7ea">conj()</a>, and <a class="el" href="namespacegko.html#ae23cfd886cee6e88d77bcbbbe1928b78">real()</a>.</p>

</div>
</div>
<a id="a9b6a9d7018703d6d1f2140054e2afe4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6a9d7018703d6d1f2140054e2afe4a">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DimensionType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structgko_1_1dim.html">dim</a>&lt;2, DimensionType&gt; gko::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structgko_1_1dim.html">dim</a>&lt; 2, DimensionType &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DimensionType</td><td>datatype used to represent each dimension</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimensions</td><td>original object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structgko_1_1dim.html">dim&lt;2&gt;</a> object with its dimensions swapped </dd></dl>

</div>
</div>
<a id="a859dc47a462721d83728d91ab7fa2148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859dc47a462721d83728d91ab7fa2148">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gko::write </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads a matrix stored in matrix market format from an input stream. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>a <a class="el" href="classgko_1_1ReadableFromMatrixData.html" title="A LinOp implementing this interface can read its data from a matrix_data structure.">ReadableFromMatrixData</a> <a class="el" href="classgko_1_1LinOp.html">LinOp</a> type used to store the matrix once it's been read from disk. </td></tr>
    <tr><td class="paramname">StreamType</td><td>type of stream used to write the data to</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">matrix</td><td>the matrix to write </td></tr>
    <tr><td class="paramname">layout</td><td>the layout used in the output </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="namespacegko.html#ab31feb99c64fc6df58ac09abd4af69b6">write_raw()</a>.</p>

</div>
</div>
<a id="ab31feb99c64fc6df58ac09abd4af69b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31feb99c64fc6df58ac09abd4af69b6">&#9670;&nbsp;</a></span>write_raw()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void gko::write_raw </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgko_1_1matrix__data.html">matrix_data</a>&lt; ValueType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68">layout_type</a>&#160;</td>
          <td class="paramname"><em>layout</em> = <code><a class="el" href="namespacegko.html#ae749a5ea11a93c1bcc9158d9a6e9fb68af1f713c9e000f5d3f280adbd124df4f5">layout_type::array</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="structgko_1_1matrix__data.html" title="This structure is used as an intermediate data type to store a sparse matrix.">matrix_data</a> structure to a stream in matrix market format. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>type of matrix values </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of matrix indexes</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>output stream where the data is to be written </td></tr>
    <tr><td class="paramname">data</td><td>the matrix data to write </td></tr>
    <tr><td class="paramname">layout</td><td>the layout used in the output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is an advanced routine that writes the raw matrix data structure. If you are trying to write an existing matrix, consider using <a class="el" href="namespacegko.html#a859dc47a462721d83728d91ab7fa2148" title="Reads a matrix stored in matrix market format from an input stream.">gko::write</a> instead. </dd></dl>

<p class="reference">Referenced by <a class="el" href="namespacegko.html#a859dc47a462721d83728d91ab7fa2148">write()</a>.</p>

</div>
</div>
<a id="a70dbe01ff95c7b953d3d737424c6feb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dbe01ff95c7b953d3d737424c6feb5">&#9670;&nbsp;</a></span>zero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the additive identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>additive identity for T </dd></dl>

</div>
</div>
<a id="a9f1cd7be946b9a2c15b01b744cf3e732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1cd7be946b9a2c15b01b744cf3e732">&#9670;&nbsp;</a></span>zero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T gko::zero </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the additive identity for T. </p>
<dl class="section return"><dt>Returns</dt><dd>additive identity for T</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This version takes an unused reference argument to avoid complicated calls like <code>zero&lt;decltype(x)&gt;()</code>. Instead, it allows <code>zero(x)</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
