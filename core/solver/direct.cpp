// SPDX-FileCopyrightText: 2017 - 2025 The Ginkgo authors
//
// SPDX-License-Identifier: BSD-3-Clause

#include "ginkgo/core/solver/direct.hpp"

#include <memory>
#include <string>

#include <ginkgo/core/base/precision_dispatch.hpp>
#include <ginkgo/core/factorization/factorization.hpp>
#include <ginkgo/core/solver/solver_base.hpp>

#include "core/config/config_helper.hpp"


namespace gko {
namespace experimental {
namespace solver {


template <typename ValueType, typename IndexType>
class Direct<ValueType, IndexType>::Factory::DirectReuseData
    : public BaseReuseData {
    friend class Direct;
    friend class Factory;

public:
    DirectReuseData() = default;

    bool is_empty() const
    {
        // the other members should be consistent since we only use them
        // internally.
        return factorization_reuse_ == nullptr;
    }

private:
    std::unique_ptr<BaseReuseData> factorization_reuse_;
    std::unique_ptr<BaseReuseData> lower_solve_reuse_;
    std::unique_ptr<BaseReuseData> upper_solve_reuse_;
};


template <typename ValueType, typename IndexType>
std::unique_ptr<LinOpFactory::ReuseData>
Direct<ValueType, IndexType>::Factory::create_empty_reuse_data() const
{
    return std::make_unique<DirectReuseData>();
}


template <typename ValueType, typename IndexType>
auto Direct<ValueType, IndexType>::Factory::generate_reuse(
    std::shared_ptr<const LinOp> input, BaseReuseData& reuse_data) const
    -> std::unique_ptr<Direct>
{
    return as<Direct>(LinOpFactory::generate_reuse(input, reuse_data));
}


template <typename ValueType, typename IndexType>
void Direct<ValueType, IndexType>::Factory::check_reuse_consistent(
    const LinOp* input, BaseReuseData& reuse_data) const
{
    auto& rrd = *as<DirectReuseData>(&reuse_data);
    if (rrd.is_empty()) {
        return;
    }
    GKO_ASSERT_IS_SQUARE_MATRIX(input);
    this->get_parameters().factorization->check_reuse_consistent(
        input, *rrd.factorization_reuse_);
    // the other factories must be consistent, since they were built based on
    // the matrix generated by factorization.
}


template <typename ValueType, typename IndexType>
std::unique_ptr<LinOp>
Direct<ValueType, IndexType>::Factory::generate_reuse_impl(
    std::shared_ptr<const LinOp> input, BaseReuseData& reuse_data) const
{
    return std::unique_ptr<Direct<ValueType, IndexType>>(
        new Direct{this, input, static_cast<DirectReuseData&>(reuse_data)});
}


template <typename ValueType, typename IndexType>
typename Direct<ValueType, IndexType>::parameters_type
Direct<ValueType, IndexType>::parse(const config::pnode& config,
                                    const config::registry& context,
                                    const config::type_descriptor& td_for_child)
{
    auto params = Direct<ValueType, IndexType>::build();
    config::config_check_decorator config_check(config);
    if (auto& obj = config_check.get("num_rhs")) {
        params.with_num_rhs(gko::config::get_value<size_type>(obj));
    }
    if (auto& obj = config_check.get("factorization")) {
        params.with_factorization(
            gko::config::parse_or_get_factory<const LinOpFactory>(
                obj, context, td_for_child));
    }

    return params;
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>::Direct(const Direct& other)
    : EnableLinOp<Direct>{other.get_executor()}
{
    *this = other;
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>::Direct(Direct&& other)
    : EnableLinOp<Direct>{other.get_executor()}
{
    *this = std::move(other);
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>& Direct<ValueType, IndexType>::operator=(
    const Direct& other)
{
    if (this != &other) {
        EnableLinOp<Direct>::operator=(other);
        gko::solver::EnableSolverBase<Direct, factorization_type>::operator=(
            other);
        const auto exec = this->get_executor();
        lower_solver_ = other.lower_solver_->clone(exec);
        upper_solver_ = other.upper_solver_->clone(exec);
    }
    return *this;
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>& Direct<ValueType, IndexType>::operator=(
    Direct&& other)
{
    if (this != &other) {
        EnableLinOp<Direct>::operator=(std::move(other));
        gko::solver::EnableSolverBase<Direct, factorization_type>::operator=(
            std::move(other));
        const auto exec = this->get_executor();
        lower_solver_ = std::move(other.lower_solver_);
        upper_solver_ = std::move(other.upper_solver_);
    }
    return *this;
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>::Direct(std::shared_ptr<const Executor> exec)
    : EnableLinOp<Direct>{exec}
{}


template <typename ValueType, typename IndexType>
static std::shared_ptr<const factorization::Factorization<ValueType, IndexType>>
generate_factorization(
    std::shared_ptr<const LinOpFactory> factorization_factory,
    std::shared_ptr<const LinOp> system_matrix)
{
    if (auto factorization = std::dynamic_pointer_cast<
            const factorization::Factorization<ValueType, IndexType>>(
            system_matrix)) {
        return factorization;
    } else {
        return as<factorization::Factorization<ValueType, IndexType>>(
            factorization_factory->generate(system_matrix));
    }
}


struct storage_type_info {
    bool lower_unit_diag;
    bool upper_unit_diag;
    bool separate_diag;
    bool combined;
    bool empty;
};


template <typename ValueType, typename IndexType>
static storage_type_info info_from_factors(
    const factorization::Factorization<ValueType, IndexType>* factors)
{
    using factorization::storage_type;
    auto type = factors->get_storage_type();
    storage_type_info result{};
    result.lower_unit_diag = type == storage_type::combined_lu ||
                             type == storage_type::combined_ldu ||
                             type == storage_type::symm_combined_ldl;
    result.upper_unit_diag = type == storage_type::combined_ldu ||
                             type == storage_type::symm_combined_ldl;
    result.separate_diag = factors->get_diagonal() ||
                           type == storage_type::combined_ldu ||
                           type == storage_type::symm_combined_ldl;
    result.combined =
        type != storage_type::empty && type != storage_type::composition;
    result.empty = type == storage_type::empty;
    return result;
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>::Direct(const Factory* factory,
                                     std::shared_ptr<const LinOp> system_matrix)
    : EnableLinOp<Direct>{factory->get_executor(), system_matrix->get_size()},
      gko::solver::EnableSolverBase<
          Direct, factorization::Factorization<ValueType, IndexType>>{
          generate_factorization<ValueType, IndexType>(
              factory->get_parameters().factorization, system_matrix)}
{
    const auto factors = this->get_system_matrix();
    const auto exec = this->get_executor();
    auto info = info_from_factors(factors.get());
    if (info.separate_diag) {
        GKO_NOT_SUPPORTED(factors->get_storage_type());
    }
    const auto num_rhs = factory->get_parameters().num_rhs;
    const auto lower_factory = lower_type::build()
                                   .with_num_rhs(num_rhs)
                                   .with_unit_diagonal(info.lower_unit_diag)
                                   .on(exec);
    const auto upper_factory = upper_type::build()
                                   .with_num_rhs(num_rhs)
                                   .with_unit_diagonal(info.upper_unit_diag)
                                   .on(exec);
    if (info.empty) {
        // remove the factor storage entirely
        this->clear();
        return;
    }
    if (info.combined) {
        // TODO handle diagonal
        lower_solver_ = lower_factory->generate(factors->get_combined());
        upper_solver_ = upper_factory->generate(factors->get_combined());
    } else {
        // TODO handle diagonal
        lower_solver_ = lower_factory->generate(factors->get_lower_factor());
        upper_solver_ = upper_factory->generate(factors->get_upper_factor());
    }
}


template <typename ValueType, typename IndexType>
Direct<ValueType, IndexType>::Direct(const Factory* factory,
                                     std::shared_ptr<const LinOp> system_matrix,
                                     typename Factory::DirectReuseData& drd)
    : EnableLinOp<Direct>{factory->get_executor(), system_matrix->get_size()},
      gko::solver::EnableSolverBase<
          Direct, factorization::Factorization<ValueType, IndexType>>{}
{
    const auto exec = this->get_executor();
    auto from_scratch = drd.is_empty();

    if (from_scratch) {
        drd.factorization_reuse_ =
            factory->get_parameters().factorization->create_empty_reuse_data();
    }
    auto factors = as<factorization_type>(
        share(factory->get_parameters().factorization->generate_reuse(
            system_matrix, *drd.factorization_reuse_)));
    this->set_system_matrix(factors);
    auto info = info_from_factors(factors.get());
    if (info.separate_diag) {
        GKO_NOT_SUPPORTED(factors->get_storage_type());
    }
    const auto num_rhs = factory->get_parameters().num_rhs;
    const auto lower_factory = lower_type::build()
                                   .with_num_rhs(num_rhs)
                                   .with_unit_diagonal(info.lower_unit_diag)
                                   .on(exec);
    const auto upper_factory = upper_type::build()
                                   .with_num_rhs(num_rhs)
                                   .with_unit_diagonal(info.upper_unit_diag)
                                   .on(exec);
    if (from_scratch) {
        drd.lower_solve_reuse_ = lower_factory->create_empty_reuse_data();
        drd.upper_solve_reuse_ = upper_factory->create_empty_reuse_data();
    }
    if (info.empty) {
        // store an empty factorization (unlike the other constructor, we didn't
        // set the system matrix here yet)
        return;
    }
    if (info.combined) {
        // TODO handle diagonal
        lower_solver_ = as<lower_type>(lower_factory->generate_reuse(
            factors->get_combined(), *drd.lower_solve_reuse_));
        upper_solver_ = as<upper_type>(upper_factory->generate_reuse(
            factors->get_combined(), *drd.upper_solve_reuse_));
    } else {
        // TODO handle diagonal
        lower_solver_ = as<lower_type>(lower_factory->generate_reuse(
            factors->get_lower_factor(), *drd.lower_solve_reuse_));
        upper_solver_ = as<upper_type>(upper_factory->generate_reuse(
            factors->get_upper_factor(), *drd.upper_solve_reuse_));
    }
}


template <typename ValueType, typename IndexType>
void Direct<ValueType, IndexType>::apply_impl(const LinOp* b, LinOp* x) const
{
    if (!this->get_system_matrix() || !this->lower_solver_ ||
        !this->upper_solver_) {
        return;
    }
    precision_dispatch_real_complex<ValueType>(
        [this](auto dense_b, auto dense_x) {
            using ws = gko::solver::workspace_traits<Direct>;
            this->setup_workspace();
            auto intermediate = this->create_workspace_op_with_config_of(
                ws::intermediate, dense_b);
            lower_solver_->apply(dense_b, intermediate);
            upper_solver_->apply(intermediate, dense_x);
        },
        b, x);
}


template <typename ValueType, typename IndexType>
void Direct<ValueType, IndexType>::apply_impl(const LinOp* alpha,
                                              const LinOp* b, const LinOp* beta,
                                              LinOp* x) const
{
    if (!this->get_system_matrix() || !this->lower_solver_ ||
        !this->upper_solver_) {
        return;
    }
    precision_dispatch_real_complex<ValueType>(
        [this](auto dense_alpha, auto dense_b, auto dense_beta, auto dense_x) {
            using ws = gko::solver::workspace_traits<Direct>;
            this->setup_workspace();
            auto intermediate = this->create_workspace_op_with_config_of(
                ws::intermediate, dense_b);
            lower_solver_->apply(dense_b, intermediate);
            upper_solver_->apply(dense_alpha, intermediate, dense_beta,
                                 dense_x);
        },
        alpha, b, beta, x);
}


#define GKO_DECLARE_DIRECT(ValueType, IndexType) \
    class Direct<ValueType, IndexType>

GKO_INSTANTIATE_FOR_EACH_VALUE_AND_INDEX_TYPE(GKO_DECLARE_DIRECT);


}  // namespace solver
}  // namespace experimental


namespace solver {


template <typename ValueType, typename IndexType>
int workspace_traits<gko::experimental::solver::Direct<ValueType, IndexType>>::
    num_arrays(const Solver&)
{
    return 0;
}


template <typename ValueType, typename IndexType>
int workspace_traits<gko::experimental::solver::Direct<ValueType, IndexType>>::
    num_vectors(const Solver&)
{
    return 1;
}


template <typename ValueType, typename IndexType>
std::vector<std::string> workspace_traits<gko::experimental::solver::Direct<
    ValueType, IndexType>>::op_names(const Solver&)
{
    return {"intermediate"};
}


template <typename ValueType, typename IndexType>
std::vector<std::string> workspace_traits<gko::experimental::solver::Direct<
    ValueType, IndexType>>::array_names(const Solver&)
{
    return {};
}


template <typename ValueType, typename IndexType>
std::vector<int> workspace_traits<gko::experimental::solver::Direct<
    ValueType, IndexType>>::scalars(const Solver&)
{
    return {};
}


template <typename ValueType, typename IndexType>
std::vector<int> workspace_traits<gko::experimental::solver::Direct<
    ValueType, IndexType>>::vectors(const Solver&)
{
    return {intermediate};
}


#define GKO_DECLARE_DIRECT_TRAITS(ValueType, IndexType) \
    struct workspace_traits<                            \
        gko::experimental::solver::Direct<ValueType, IndexType>>

GKO_INSTANTIATE_FOR_EACH_VALUE_AND_INDEX_TYPE(GKO_DECLARE_DIRECT_TRAITS);


}  // namespace solver
}  // namespace gko
